#!/bin/sh
#Written by mistfire with some references from petget
. /etc/rc.d/PUPSTATE
. /etc/DISTRO_SPECS #has DISTRO_BINARY_COMPAT, DISTRO_COMPAT_VERSION

MASTERDB="pkg-master-db"
PKGMDB="/root/.packages/$MASTERDB"
mcommand=""
GTKVERLIST='1.0 2.0 3.0'

if [ -f /root/.packages/download_path ]; then
 . /root/.packages/download_path
 [ -d "$DL_PATH" -a -w "$DL_PATH" ] && DL_PATH="$DL_PATH" || DL_PATH="/root"
else
 DL_PATH="/root"
fi

if [ -d /root/.packages/package-files ]; then
PKGFILEPATH="/root/.packages/package-files"
else
PKGFILEPATH="/root/.packages"
fi

if [ -d /root/.packages/remove-script ]; then
PKGRMSCRIPT="/root/.packages/remove-script"
else
PKGRMSCRIPT="/root/.packages"
fi

##### FUNCTIONS #####

get_free_disk_space(){

case $PUPMODE in
  6|12)
   if [ -L /initrd/pup_rw ]; then
    SIZEFREEM=`df -m | grep ' /initrd/mnt/dev_save$' | tr -s ' ' | cut -f 4 -d ' '`
   else
    SIZEFREEM=`df -m | grep ' /initrd/pup_rw$' | tr -s ' ' | cut -f 4 -d ' '`
   fi
  ;;
  3|7|13)
   if [ -L /initrd/pup_ro1 ]; then
    SIZEFREEM=`df -m | grep ' /initrd/mnt/dev_save$' | tr -s ' ' | cut -f 4 -d ' '`
   else
    SIZEFREEM=`df -m | grep ' /initrd/pup_ro1$' | tr -s ' ' | cut -f 4 -d ' '`
   fi
  ;;
  16|24|17|25)
   memFREEK=`free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 4 -d ' '`
   swapFREEK=`free | grep -o 'Swap: .*' | tr -s ' ' | cut -f 4 -d ' '`
   SIZEFREEK=`expr $memFREEK + $swapFREEK`
   SIZEFREEM=`expr $SIZEFREEK \/ 1024`
  ;;
  *)
   SIZEFREEM=`df -m | grep ' /$' | head -n 1 | tr -s ' ' | cut -f 4 -d ' '` #110509 rerwin: insert head -n 1
  ;;
esac	
	
	
}


fix_broken_symlinks(){
for LIBx in $(cat /tmp/ppg-libfiles.txt)
do
LIBDN="$(dirname $LIBx)"
BLIB="$(basename $LIBx)"
	if [ ! -L ${LIBx} ] && [ -f ${LIBx} ]; then
	   LBN="$(echo "$BLIB" | sed -e "s#\.so#\|#g")"
	   xLIB="$(echo "$LBN" | cut -f 1 -d '|')"   
	   if [ "$xLIB" != "" ]; then
		 SLL=$(find ${LIBDN} -type l -name "${xLIB}.so*" -maxdepth 1 | tr '\n' ' ')
			if [ "$SLL" != "" ]; then
			  for SLINK in $SLL
			  do
				  BLINK="$(basename $SLINK)"
				  RL="$(readlink ${LIBDN}/$BLINK)"
				  if [ "$(echo $RL | cut -c 1)" != "/" ]; then
					xRL="$(basename $RL)"
					if [ ! -f ${LIBDN}/$xRL ]; then
					 rm -f $SLINK
					 ln -s ${LIBx} $SLINK
					fi
				  elif [ "$(echo $RL | cut -c 1)" == "/" ]; then
					if [ ! -f $RL ]; then
					 rm -f $SLINK
					 ln -s ${LIBx} $SLINK
					fi
				  else
					 rm -f $SLINK
					 ln -s ${LIBx} $SLINK					    
				  fi
			  done
			fi
	   fi
	fi
done	
}

update_file_list(){

pkg1="$1"

pkgfound=`cat /root/.packages/user-installed-packages | grep "|$pkg1|" | cut -f 1 -d '|'`

if [ "$pkgfound" != "" ]; then

while IFS='' read -r line || [[ -n "$line" ]]; do

 if [ "$(cat /root/.packages/package-files/${DLPKG_NAME}.files | grep "$line")" == "" ]; then
 echo "$line" >> /root/.packages/package-files/${DLPKG_NAME}.files
 fi
	
done < /root/.packages/package-files/$pkgfound.files

rm -f /root/.packages/package-files/$pkgfound.files

cat /root/.packages/user-installed-packages | grep -v "|$pkg1|" > /root/.packages/user-installed-packages.new
mv -f /root/.packages/user-installed-packages.new /root/.packages/user-installed-packages

fi

}

write_deb_spec(){

if [ ! -f /DEBIAN/control ]; then
return
fi

#pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|

pkgname="${DLPKG_NAME}"
nameonly=`cat /DEBIAN/control | grep "Package:" | cut -f 2 -d ':' | sed -e "s#^ ##g"`
version=`cat /DEBIAN/control | grep "Version:" | cut -f 2 -d ':' | sed -e "s#^ ##g" | cut -f 1 -d '-'`
pkgrelease=`cat /DEBIAN/control | grep "Version:" | cut -f 2 -d ':' | sed -e "s#^ ##g" | cut -f 2 -d '-'`
category=""
size="${PKGSIZEK}K"
path=""	
fullfilename=${DLPKG_BASE}
description=`cat /DEBIAN/control | grep "Description:" | cut -f 2 -d ':' | sed -e "s#^ ##g" | head -1`
dependencies=""
depends=`cat /DEBIAN/control | grep "Depends:" | cut -f 2 -d ':' | sed -e "s#^ ##g" -e "s#, # #g" -e "s#(#|#g" -e "s# |#|#g" -e "s# [0-9]##g"` 

for dep1 in $depends
do
depname=`echo $dep1 | cut -f 1 -d '|'`
 if [ "$dependencies" == "" ]; then
 dependencies="+$depname"
 else
 dependencies="$dependencies,+$depname"
 fi
done 

echo "$pkgname|$nameonly|$version|$pkgrelease|$category|$size|$path|$fullfilename|$dependencies|$description|" > /pet.specs	
	
}

write_arch_spec(){

if [ ! -f /.PKGINFO ]; then
return
fi

pkgname="${DLPKG_NAME}"
nameonly=`cat /.PKGINFO | grep "pkgname =" | cut -f 2 -d '=' | sed -e "s#^ ##g"`
version=`cat /.PKGINFO | grep "pkgver =" | cut -f 2 -d '=' | sed -e "s#^ ##g" | cut -f 1 -d '-'`
pkgrelease=`cat /.PKGINFO | grep "pkgver =" | cut -f 2 -d '=' | sed -e "s#^ ##g" | cut -f 2 -d '-'`
category=""
size="${PKGSIZEK}K"
path=""	
fullfilename=${DLPKG_BASE}
description=`cat /.PKGINFO | grep "pkgdesc" | cut -f 2 -d '=' | sed -e "s#^ ##g"`
dependencies=""

for dep1 in `cat /.PKGINFO | grep "depend =" | sed "s# = #=#g"`
do
depname=`echo $dep1 | cut -f 2 -d '=' | sed -e "s#^ ##g"`
 if [ "$dependencies" == "" ]; then
 dependencies="+$depname"
 else
 dependencies="$dependencies,+$depname"
 fi
done 

echo "$pkgname|$nameonly|$version|$pkgrelease|$category|$size|$path|$fullfilename|$dependencies|$description|" > /pet.specs	
	
}

write_slack_spec(){
	
if [ ! -f /install/slack-desc ]; then
return
fi

pkgname="${DLPKG_NAME}"
nameonly=`cat /install/slack-desc | grep ": " | head -n 1 | cut -f 1 -d ":" | sed -e "s#^ ##g"`
version="$DB_version"
pkgrelease="$DB_pkgrelease"
category=""
size="${PKGSIZEK}K"
path=""	
fullfilename=${DLPKG_BASE}
description=`cat /install/slack-desc | grep ": " | head -n 1 | cut -f 2 -d ":" | sed -e "s#^ ##g" | cut -f 2 -d '(' | sed -e "s#)##g"`

dependencies=""

if [ -f /install/slack-required ]; then

for dep1 in `cat /install/slack-required | sed -e "s#| #\n##g" | cut -f 1 -d ' '`
do
 if [ "$dependencies" == "" ]; then
 dependencies="+$dep1"
 else
 dependencies="$dependencies,+$dep1"
 fi
done 

fi

echo "$pkgname|$nameonly|$version|$pkgrelease|$category|$size|$path|$fullfilename|$dependencies|$description|" > /pet.specs	
	
}

write_rpm_spec(){
	
if [ ! -f /rpm-info ]; then
return
fi

pkgname="${DLPKG_NAME}"
nameonly=`cat /rpm-info | grep "Name" | grep ":" | cut -f 2 -d ':' | sed -e "s#^ ##g"`
version=`cat /rpm-info | grep "Version" | grep ":" | cut -f 2 -d ':' | sed -e "s#^ ##g"`
pkgrelease=`cat /rpm-info | grep "Release" | grep ":" | cut -f 2 -d ':' | sed -e "s#^ ##g"`
category=`cat /rpm-info | grep "Group" | grep ":" | cut -f 2 -d ':' | sed -e "s#^ ##g"`
size="${PKGSIZEK}K"
path=""	
fullfilename=${DLPKG_BASE}
description=`cat /rpm-info | grep "Summary" | grep ":" | cut -f 2 -d ':' | sed -e "s#^ ##g"`

dependencies=""

echo "$pkgname|$nameonly|$version|$pkgrelease|$category|$size|$path|$fullfilename|$dependencies|$description|" > /pet.specs	

rm -f /rpm-info
	
}

exit_unlock(){
rm -f /tmp/process-ppg.lock > /dev/null
exit
}

check_process_lock(){

if [ -f /tmp/process-ppg.lock ]; then
echo "Process was already running. Please wait until finished"
exit
fi

}

clean_temp_file(){
rm -f /tmp/ppg-* > /dev/null
rm -f /tmp/ppg_* > /dev/null	
}

update_menu_func(){
[ ! "$HOME" ] && HOME='/root'
[ "$HOME" = "/" ] && HOME='/root'
export HOME

[ -f $HOME/.jwm/menuheights ] && . $HOME/.jwm/menuheights

# remove csh shell files #precaution
CSH=$(find /etc/profile.d -name *.csh)
[ "$CSH" ] && rm /etc/profile.d/*.csh

if [ "$LANG" = "C" ];then #120208
 LANG="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
 export LANG
fi
LANG1="`echo -n $LANG | cut -f 1 -d '_'`"  #120207 ex: de

if [ -d /etc/xdg/templates ]; then

TEMPLATES="`ls -1 /etc/xdg/templates | tr '\n' ' '`"

for ONETPL in $TEMPLATES #ex: _root_.jwmrc
do
 [ "$ONETPL" = "README.txt" ] && continue
 ONEDEST="`echo -n "$ONETPL" | sed -e 's/_/\//g'`"
 ONESRC="/etc/xdg/templates/$ONETPL"
 echo "Generating $ONEDEST..."
 ONEPATH="`dirname $ONEDEST`"
 
 [ -f $ONEDEST ] && mv -f $ONEDEST ${ONEDEST}-previous

 if [ -d $ONEPATH ]; then

	 cat $ONESRC |
	 while read ONELINE
	 do
	  EXECMENU="`echo -n "$ONELINE" | grep -o 'PUPPYMENU.*' | cut -f 2-5 -d ' '`"
	  if echo "$ONELINE" | grep -q "MENHEIGHT" ;then #131213 designed to be backward compatible
	   [ "$MENHEIGHT" ] && echo $ONELINE | sed "s%MENHEIGHT%$MENHEIGHT%" >> $ONEDEST \
	   || echo $ONELINE | sed "s%MENHEIGHT%24%" >> $ONEDEST
	  elif [ "$EXECMENU" = "" ];then
	   echo "$ONELINE" >> $ONEDEST
	  else
	   ${EXECMENU} >> ${ONEDEST}
	  fi
	 done
 
 fi
 
 #120207 translate some strings... 120216...
 if [ "$LANG1" != "en" ];then
  if [ -f /usr/share/sss/menu_strings/menu_strings.${LANG1} ];then
   sPTN="/^\[${ONETPL}\]/,/^$/p" #this is a multi-line block find expression.
   CODEBLOCK="`sed -n "$sPTN" /usr/share/sss/menu_strings/menu_strings.${LANG1} | sed -e '/^#/d' -e '/%%/d' -e '/^$/d' -e '/^\[/d'`" #extracts just the relevant block of lines.
   if [ "$CODEBLOCK" ];then
    echo "$CODEBLOCK" > /tmp/fixmenus-translationblock
    #121124 ensure that all [ ] are escaped... 121125 revert... 121126 restore, plus escape '.' chars...
    sed -i -e 's%\[%\\[%g' -e 's$\]$\\]$g' -e 's%\\\\\[%\\[%g' -e 's%\\\\\]%\\]%g' /tmp/fixmenus-translationblock
    sed -i -e 's%\.%\\.%g' -e 's%\\\\\.%\\.%g' /tmp/fixmenus-translationblock #note: 2nd ptn gets rid of prior escape char, so there remains just one.
    sed -i -f /tmp/fixmenus-translationblock ${ONEDEST}
   fi
  fi
 fi

done

fi

#w001 support for fbpanel, lxpanel, openbox, fluxbox, pekwm, xfce4-panel...
[ `which variconlinks` ] && variconlinks #100404 for my fbpanel pkg.
[ `which tempicons` ] && tempicons
[ `which fbpanel_menu_refresh` ] && fbpanel_menu_refresh
[ `which lxpanel_menu_refresh` ] && lxpanel_menu_refresh
[ `which jwm2fluxbox` ] && jwm2fluxbox  ##current fluxbox_menu_refresh doesn't support menu icons while this does
[ `which obmenu-refresh` ] && obmenu-refresh
[ `which jwm2pekwm` ] && jwm2pekwm

[ `pidof xfce4-panel` ] && xfce4-panel -r

if [ "`pidof jwm`" != "" ];then #120101
JWMVER=`jwm -v|head -n1|cut -d ' ' -f2|cut -d - -f2`
	if vercmp $JWMVER lt 574;then #120116 547 to 574.
	 jwm -restart #screen will flicker.
	else
	 jwm -reload
	fi
fi

[ `pidof icewm` ] && icewm --restart

#gtk-update-icon-cache -f -i /usr/share/icons/hicolor
#touch --no-create /usr/share/applications/	
	
}

hacks_postinstall(){
INSTALLEDPKG="$1" #ex: vlc_2.0.3-0ubuntu0.12.04.1_i386, without .deb
INSTALLEDNAME="$2" #130326

case $INSTALLEDPKG in
 vlc-nox_*)
  #120907 vlc in debian/ubuntu configured to not run as root (it is a pre-compile configure option to enable running as root).
  #this hack will fix it...
  #note, this code is also in FIXUPHACK in 'vlc' template.
  if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
   if [ -f /usr/bin/vlc  ];then
    bbe -e 's/geteuid/getppid/' /usr/bin/vlc > /tmp/vlc-temp1
    mv -f /tmp/vlc-temp1 /usr/bin/vlc
    chmod 755 /usr/bin/vlc
   fi
  fi
 ;;
 google-chrome-*) #130221 pemasu. 130224 pemasu: limit cache size...
  if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
   if [ -f /opt/google/chrome/chrome  ];then
    bbe -e 's/geteuid/getppid/' /opt/google/chrome/chrome > /tmp/chrome-temp1
    mv -f /tmp/chrome-temp1 /opt/google/chrome/chrome
    chmod 755 /opt/google/chrome/chrome
    [ -e /usr/bin/google-chrome ] && rm -f /usr/bin/google-chrome
    echo '#!/bin/sh
exec /opt/google/chrome/google-chrome --user-data-dir=/root/.config/chrome --disk-cache-size=10000000 --media-cache-size=10000000 "$@"' > /usr/bin/google-chrome
    chmod 755 /usr/bin/google-chrome
    ln -s google-chrome /usr/bin/chrome
    ln -s /opt/google/chrome/product_logo_48.png /usr/share/pixmaps/google-chrome.png
    ln -s /opt/google/chrome/product_logo_48.png /usr/share/pixmaps/chrome.png
    CHROMEDESKTOP="`find /usr/share/applications -mindepth 1 -maxdepth 1 -iname '*chrome*.desktop'`"
    if [ "$CHROMEDESKTOP" = "" ];then #precaution.
     echo '[Desktop Entry]
Encoding=UTF-8
Version=1.0
Name=Google Chrome web browser
GenericName=Google Chrome
Comment=Google Chrome web browser
Exec=google-chrome
Terminal=false
Type=Application
Icon=google-chrome.png
Categories=WebBrowser;' > /usr/share/applications/google-chrome.desktop
    fi
   fi
  fi
 ;;
 jwm_theme_*)
  #120924 DejaVu font no good for non-Latin languages...
  #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
  LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
  case $LANGUSER in
   zh*|ja*|ko*) #chinese, japanese, korean
    sed -i -e 's%DejaVu Sans%Sans%' /etc/xdg/templates/_root_*
    sed -i -e 's%DejaVu Sans%Sans%' /root/.jwm/themes/*-jwmrc
    sed -i -e 's%DejaVu Sans%Sans%' /root/.jwm/jwmrc-theme
   ;;
  esac
  #130326 font size fix for 96 dpi...
  if [ "$INSTALLEDNAME" ];then
   JWMTHEMEFILE="$(grep '^/root/\.jwm/themes/.*-jwmrc$' $PKGFILEPATH/${INSTALLEDNAME}.files | head -n 1)"
   [ "$JWMTHEMEFILE" ] && hackfontsize "JWMTHEMES='${JWMTHEMEFILE}'"
  fi
 ;;
 openbox*)
  #120924 DejaVu font no good for non-Latin languages...
  #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
  LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
  case $LANGUSER in
   zh*|ja*|ko*) #chinese, japanese, korean
    sed -i -e 's%DejaVu Sans%Sans%' /etc/xdg/openbox/*.xml
    sed -i -e 's%DejaVu Sans%Sans%' /root/.config/openbox/*.xml
   ;;
  esac
 ;;
 gtk_theme_*)
  #120924 DejaVu font no good for non-Latin languages...
  #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
  LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
  case $LANGUSER in
   zh*|ja*|ko*) #chinese, japanese, korean
    GTKRCFILE="$(find /usr/share/themes -type f -name gtkrc | tr '\n' ' ')"
    for ONEGTKRC in $GTKRCFILE
    do
     sed -i -e 's%DejaVu Sans%Sans%' $ONEGTKRC
    done
   ;;
  esac
  #130326 font size fix for 96 dpi...
  if [ "$INSTALLEDNAME" ];then
   GTKTHEMEFILE="$(grep '^/usr/share/themes/.*/gtk-2\.0/gtkrc$' $PKGFILEPATH/${INSTALLEDNAME}.files | head -n 1)"
   [ "$GTKTHEMEFILE" ] && hackfontsize "GTKRCS='${GTKTHEMEFILE}'"
  fi
 ;;
 seamonkey*|firefox*)
  #120924 DejaVu font no good for non-Latin languages...
  #see also langpack_* pinstall.sh (template is in /usr/share/doc/langpack-template/pinstall.sh, read by momanager).
  LANGUSER="`grep '^LANG=' /etc/profile | cut -f 2 -d '=' | cut -f 1 -d ' '`"
  case $LANGUSER in
   zh*|ja*|ko*) #chinese, japanese, korean
    MOZFILE="$(find /root/.mozilla -type f -name prefs.js -o -name '*.css' | tr '\n' ' ')"
    for ONEMOZ in $MOZFILE
    do
     sed -i -e 's%DejaVu Sans%Sans%' $ONEMOZ
    done
   ;;
  esac
 ;;
 mc_*) #121206 midnight commander
  #in ubuntu, won't run from the menu. this fixes it...
  [ -f /usr/share/applications/mc.desktop ] && sed -i -e 's%^Exec=.*%Exec=TERM=xterm mc%' /usr/share/applications/mc.desktop
 ;;
 xsane*) #130122
  #xsane puts up a warning msg at startup if running as root, remove it...
  #this code is also in file FIXUPHACK in xsane template (in Woof).
  #WARNING: this may only work for x86 binary.
  if [ -f /usr/bin/bbe ];then #bbe is a sed-like utility for binary files.
   if [ -f /usr/bin/xsane  ];then
    bbe -e 's/\x6b\x00getuid/\x6b\x00getpid/' /usr/bin/xsane > /tmp/xsane-temp1
    mv -f /tmp/xsane-temp1 /usr/bin/xsane
    chmod 755 /usr/bin/xsane
   fi
  fi
 ;;
 kompozer*) #130507
  [ -f /usr/bin/kompozer ] && [ -d /usr/lib/kompozer ] && sed -i -e 's%^moz_libdir=%export MOZILLA_FIVE_HOME="/usr/lib/kompozer" #BK\nmoz_libdir=%' /usr/bin/kompozer
 ;;
esac


}

clean_and_die () {
  rm -f $PKGFILEPATH/${DLPKG_NAME}.files
  return 1
}

list_file_symlinks(){
	
	cp -f $PKGFILEPATH/${DLPKG_NAME}.files /tmp/${DLPKG_NAME}.files.bak

	while IFS='' read -r line || [[ -n $line ]]
	do
		if [ -f $line ] && [ -L $line ]; then
		  if [ -a $line ]; then
		    basename $line >> /tmp/pkg-exclude-files
		    cat /tmp/${DLPKG_NAME}.files.bak | grep -v "$line" > /tmp/${DLPKG_NAME}.files.bak2 
		    mv -f /tmp/${DLPKG_NAME}.files.bak2 /tmp/${DLPKG_NAME}.files.bak
		  fi
		fi	
	done < $PKGFILEPATH/${DLPKG_NAME}.files
	
	mv -f /tmp/${DLPKG_NAME}.files.bak $PKGFILEPATH/${DLPKG_NAME}.files
	
}

install_path_check() {
FILELIST="$PKGFILEPATH/${DLPKG_NAME}.files"
  [ -s "$FILELIST" ] || return 0 #120126 noryb009: typo
  grep -q '^/mnt' "$FILELIST" || return 0
  MNTDIRS=$(cat "$FILELIST" | grep '^/mnt/.*/$' | cut -d'/' -f1-3  | tail -n 1)
  LANG=$LANG_USER
  MSG1=$(gettext "This package will install files under")
  MSG2=$(gettext "It can be dangerous to install files under '/mnt' because it depends on the profile of installation.")
  MSG3=""
  
  if grep -q '^/mnt/home' "$FILELIST"; then
    if [ $PUPMODE -eq 5 ]; then
      MSG3=$(gettext "You are running Puppy without 'pupsave', and '/mnt/home' does not exist. In this case, you can use the RAM for this space, but strongly recommended to shutdown now to create 'pupsave' BEFORE installing these packages.")
      MSG3="$MSG3\\n$(gettext "NOTE: You can install this package for a tentative use, then do NOT make 'pupsave' with this package installed.")"
    fi
    DIRECTSAVEPATH=""
  fi
  
  
  if [ "$MSG1" != "" ]; then
  echo "$MSG1"
  fi
  
  if [ "$MSG2" != "" ]; then
  echo "$MSG2"
  fi
  
  if [ "$MSG3" != "" ]; then
  echo "$MSG3"
  fi
    
}	

replace_pkg(){

echo "Updating $oldpkg from $oldver to $ver ..."

grep -v "|$oldpkg|" $PKGMDB > /tmp/pkg-master-db.new
echo "$newentry" >> /tmp/pkg-master-db.new
mv -f /tmp/pkg-master-db.new $PKGMDB

}

update_db(){

if [ -f $PKGMDB ]; then
mv -f $PKGMDB $PKGMDB.old
fi

echo "" > $PKGMDB

if [ -d /root/.packages/repo ]; then
pkgdb=`ls -1 /root/.packages/repo`
pkgdbpath="/root/.packages/repo"
else
pkgdb=`ls -1 /root/.packages/ | grep "Packages-"`
pkgdbpath="/root/.packages"
fi

for dbfile in $pkgdb
do

PKGSUFFIX=`basename $dbfile | cut -f 3 -d '-'`
PKGTYPE=`basename $dbfile | cut -f 2 -d '-'`
 
echo "**** Processing $dbfile ($(cat $pkgdbpath/$dbfile | wc -l) packages) ****"

    while IFS='' read -r line || [[ -n $line ]]
	do
	
	PKGNAME=`echo "$line" | cut -f 2 -d '|'`
	PKGFILE=`echo "$line" | cut -f 8 -d '|'`
	VERSION=`echo "$line" | cut -f 3 -d '|' | cut -f 1 -d '-' | cut -f 1 -d '_' | sed -e 's%\-i[3456]86.*%%' -e 's%\-noarch.*%%' -e 's#[Aa-Zz]##g'`
	PKGRELEASE=`echo "$line" | cut -f 4 -d '|' | sed -e 's#[Aa-Zz]##g'`
	
	if  [ "$PKGRELEASE" == "" ]; then
	PKGRELEASE=0
	fi
	
	ver="$VERSION"
	
	PREPKG=`cat	$PKGMDB | grep "|$PKGNAME|"`
	PREVER=`cat	$PKGMDB | grep "|$PKGNAME|" | cut -f 3 -d '|' | cut -f 1 -d '-' | cut -f 1 -d '_' | sed -e 's%\-i[3456]86.*%%' -e 's%\-noarch.*%%' -e 's#[Aa-Zz]##g'`
	PKGDIR=`cat	$PKGMDB | grep "|$PKGNAME|" | cut -f 7 -d '|'`
	PREPKGRELEASE=`cat	$PKGMDB | grep "|$PKGNAME|" | cut -f 4 -d '|' | sed -e 's#[Aa-Zz]##g'`
	
	if  [ "$PREPKGRELEASE" == "" ]; then
	PREPKGRELEASE=0
	fi
	
	if [ "$PREPKG" != "" ]; then
	
		NEWMAJOR=`echo $VERSION | cut -f 1 -d '.'`
		NEWMINOR=`echo $VERSION | cut -f 2 -d '.'`
		NEWBUGFIX=`echo $VERSION | cut -f 3 -d '.'`
	    NEWREVISION=`echo $VERSION | cut -f 4 -d '.'`
	    
	    if [ "$NEWMAJOR" == "" ]; then
	    NEWMAJOR=0
	    fi
	    
	    if [ "$NEWMINOR" == "" ]; then
	    NEWMINOR=0
	    fi

	    if [ "$NEWREVISION" == "" ]; then
	    NEWREVISION=0
	    fi
	    
	    if [ "$NEWBUGFIX" == "" ]; then
	    NEWBUGFIX=0
	    fi
	    	  
		OLDMAJOR=`echo $PREVER | cut -f 1 -d '.'`
		OLDMINOR=`echo $PREVER | cut -f 2 -d '.'`
		OLDBUGFIX=`echo $PREVER | cut -f 3 -d '.'`
	    OLDREVISION=`echo $PREVER | cut -f 4 -d '.'`
	    
	    if [ "$OLDMAJOR" == "" ]; then
	    OLDMAJOR=0
	    fi

	    if [ "$OLDMINOR" == "" ]; then
	    OLDMINOR=0
	    fi
	    
	    if [ "$OLDBUGFIX" == "" ]; then
	    OLDBUGFIX=0
	    fi

	    if [ "$OLDREVISION" == "" ]; then
	    OLDREVISION=0
	    fi

		oldpkg="$PKGNAME"
		oldver="$PREVER"
		
		if [ "$PKGDIR" == "" ] && [ "$PKGTYPE" == "puppy" ]; then
		#pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|
	
		pkgname=`echo "$line" | cut -f 1 -d '|'`
		nameonly=`echo "$line" | cut -f 2 -d '|'`
		version=`echo "$line" | cut -f 3 -d '|'`
		pkgrelease=`echo "$line" | cut -f 4 -d '|'`
		category=`echo "$line" | cut -f 5 -d '|'`
		size=`echo "$line" | cut -f 6 -d '|'`
		path="pet_packages-$PKGSUFFIX"
		fullfilename=`echo "$line" | cut -f 8 -d '|'`
		dependencies=`echo "$line" | cut -f 9 -d '|'`
		description=`echo "$line" | cut -f 10 -d '|'`
		
		newentry="$pkgname|$nameonly|$version|$pkgrelease|$category|$size|$path|$fullfilename|$dependencies|$description|"

		else
		newentry="$line"
	    fi
	    
	    if [ "$ver" != "$PREVER" ]; then
			if [ $NEWMAJOR -gt $OLDMAJOR ]; then
			replace_pkg
			elif [ $NEWMAJOR -eq $OLDMAJOR ] && [ $NEWMINOR -gt $OLDMINOR ]; then
			replace_pkg
			elif [ $NEWMAJOR -eq $OLDMAJOR ] && [ $NEWMINOR -eq $OLDMINOR ] && [ $NEWBUGFIX -gt $OLDBUGFIX ]; then
			replace_pkg
			elif [ $NEWMAJOR -eq $OLDMAJOR ] && [ $NEWMINOR -eq $OLDMINOR ] && [ $NEWBUGFIX -eq $OLDBUGFIX ] && [ $NEWREVISION -gt $OLDREVISION ]; then
			replace_pkg
			fi
		#else
		#echo "$PKGNAME" is up-to-date
		elif [ "$PKGRELEASE" -gt "$PREPKGRELEASE" ]; then
		    replace_pkg
		fi

    else
    
    echo "Adding $PKGNAME to master database... "
    
	if [ "$PKGDIR" == "" ] && [ "$PKGTYPE" == "puppy" ]; then
	
	#pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|
	
	pkgname=`echo "$line" | cut -f 1 -d '|'`
	nameonly=`echo "$line" | cut -f 2 -d '|'`
	version=`echo "$line" | cut -f 3 -d '|'`
	pkgrelease=`echo "$line" | cut -f 4 -d '|'`
	category=`echo "$line" | cut -f 5 -d '|'`
	size=`echo "$line" | cut -f 6 -d '|'`
	path="pet_packages-$PKGSUFFIX"
	fullfilename=`echo "$line" | cut -f 8 -d '|'`
	dependencies=`echo "$line" | cut -f 9 -d '|'`
	description=`echo "$line" | cut -f 10 -d '|'`
	
	newentry="$pkgname|$nameonly|$version|$pkgrelease|$category|$size|$path|$fullfilename|$dependencies|$description|"
	
	else
	newentry="$line"
	fi
    
	echo "$newentry" >> $PKGMDB
	
	fi
	
	done < $pkgdbpath/$dbfile
	
echo ""
	
done

echo "Sorting entries..."
sort $PKGMDB > /tmp/pkg-master-db.new
mv -f /tmp/pkg-master-db.new $PKGMDB
echo "$(cat $PKGMDB | wc -l) packages in the master database."
echo "Master package database update complete"
}

build_repo(){
	
rm -f /tmp/ppg_repos	
	
. /root/.packages/DISTRO_COMPAT_REPOS
. /root/.packages/DISTRO_PET_REPOS

for ONEPETREPO in $PET_REPOS #ex: ibiblio.org|http://distro.ibiblio.org//quirky|Packages-puppy-quirky-official
   do
	URL=`echo ${ONEPETREPO} | cut -f 2 -d '|'`
 
	if [ -f /tmp/ppg_repos ]; then
		if [ "`cat /tmp/ppg_repos | grep "$URL"`" == "" ]; then
		echo "$URL" >> /tmp/ppg_repos
		fi
	else
    echo "$URL" >> /tmp/ppg_repos
    fi
  
    #...ex: ibiblio.org|http://distro.ibiblio.org//puppylinux|Packages-puppy-4-official
   done

for ONEURLENTRY in $REPOS_DISTRO_COMPAT
do
	URL=`echo ${ONEURLENTRY} | cut -f 2 -d '|'`
 
	if [ -f /tmp/ppg_repos ]; then
		if [ "`cat /tmp/ppg_repos | grep "$URL"`" == "" ]; then
		echo "$URL" >> /tmp/ppg_repos
		fi
	else
    echo "$URL" >> /tmp/ppg_repos
    fi
done
	
}

download_pkgs(){

getpkg="$1"
	
ONELIST=`cat $PKGMDB | grep "|$getpkg|" | cut -f 7,8,13 -d '|'` #path|fullfilename|repo-id

ONEREPOID="`echo -n "$ONELIST" | cut -f 3 -d '|'`" #ex: official (...|puppy|wary5|official|)
ONEPATH="`echo -n "$ONELIST" | cut -f 1 -d '|'`"
ONEPKGNAME="`echo -n "$ONELIST" | cut -f 2 -d '|'`"
ONEFILE="`echo -n "$ONELIST" | cut -f 1,2 -d '|' | tr '|' '/'`" #path/fullfilename

ext=`echo -n "$ONELIST" | rev | cut -c 2-4 | rev`

#echo "$ext----- " >> /root/logs

PKGFOUND=0
DOWNLOADFROM=""

echo "Searching download links for $getpkg ..."
   
for line1 in `cat /tmp/ppg_repos`
do

if [ $PKGFOUND -eq 0 ]; then

	URL_PATH="`echo -n "$line1" | cut -f 2 -d '|'`"
	
	wget -q -4 -t 1 -T 5 --spider "${URL_PATH}/${ONEFILE}"
	
	if [ $? -eq 0 ]; then
	 echo "Download link found: $getpkg"
	 PKGFOUND=1
	 DOWNLOADFROM="${URL_PATH}/${ONEFILE}"
	 break
	fi	

fi

done


if [ "$DOWNLOADFROM" != "" ]; then

echo ""

cd $DL_PATH

	if [ "`which axel`" != "" ]; then
	axel -n 4 "$DOWNLOADFROM"
	ret=$?
	else
	wget -4 -t 5 -w 5 "$DOWNLOADFROM"
	ret=$?
	fi

echo ""

	if [ $ret -eq 0 ]; then
	echo "Package downloaded: $getpkg"
	echo "$DL_PATH/$getpkg" >> /tmp/ppg-success
	else
	echo "Failed to download package: $getpkg"
	echo "$DL_PATH/$getpkg" >> /tmp/ppg-failed
	fi
	
else
	echo "Download link not found: $getpkg"
	echo "$DL_PATH/$getpkg" >> /tmp/ppg-failed
fi
	
	
}

install_pkgs(){

for pg in `cat /tmp/ppg-success`
do
#insert install function here"
install_func $pg
	if [ $? -eq 0 ]; then
	echo "$pg" >> /tmp/ppg-install-pkg-good
	else
	echo "$pg" >> /tmp/ppg-install-pkg-bad
	fi
sleep 1
done
	
}

find_depends(){

depname="$1"

woofpkg=`cat /root/.packages/woof-installed-packages | grep "|$depname|"`
userpkg=`cat /root/.packages/user-installed-packages | grep "|$depname|"`

if [ "$woofpkg" == "" ] && [ "$userpkg" == "" ]; then

#echo "Looking for $depname in the database..."

pkg=`cat $PKGMDB | grep "|$depname|"`

	if [ "$pkg" != "" ]; then

	pkgmatch=`echo "$pkg" | cut -f 2 -d '|'`
	
	  if [ "$pkgmatch" == "$depname" ]; then
	
		pkgfile=`echo "$pkg" | cut -f 8 -d '|'`
		pkgsize=`echo "$pkg" | cut -f 6 -d '|'`
		
			if [ -f /tmp/ppg-download-pkg ]; then
				pkgfound=`cat /tmp/ppg-download-pkg | grep "$pkgfile"`
				if [ "$pkgfound" == "" ]; then
				echo "$pkgfile|$pkgsize|$mainpkg" >> /tmp/ppg-download-pkg
				echo "$depname" >> /tmp/ppg-looked
				fi
			else
			echo "$pkgfile|$pkgsize|$mainpkg" >> /tmp/ppg-download-pkg
			echo "$depname" >> /tmp/ppg-looked
			fi
		
			subdeps=`echo "$pkg" | cut -f 9 -d '|' | sed -e 's%&ge%_%g' | sed -e 's%&eq%_%g' | sed -e 's%&gt%_%g' | sed -e 's%,% %g'` 

			#echo "$subdeps"

			#subdeps=`echo "$subdeps" | sed -e 's%gtk2%gtk+2%g' | sed -e 's%gtk3%gtk+3%g' | sed -e 's%libstdc %libstdc++ %g'` 	
		
			for d1 in $subdeps
			do
				if [ "$d1" != "$depname" ]; then
				
				d1=`echo "$d1" | sed -e 's#^+##g' | cut -f 1 -d '_'`
				
					if [ -f /tmp/ppg-looked ]; then
					looked=`cat /tmp/ppg-looked | grep "$d1"`
					else
					looked=""
					fi
					
					if [ "$looked" == "" ]; then
					 find_depends "$d1"
					fi
				fi
			done
		fi
	fi
else
#echo "$depname was already installed"
echo "$depname" >> /tmp/ppg-looked
fi	
	
	
}

process_info(){
	
CNT1=0
pkgnames=""

for pkg in $prepkgs
do

	if [ $CNT1 -gt 0 ] && [ "$pkg" != "" ]; then
		if [ "$pkgnames" != "" ]; then
		pkgnames="$pkgnames $pkg"
		else
		pkgnames="$pkg"
		fi
	fi

CNT1=`expr $CNT1 + 1`

done

if [ "$pkgnames" == "" ]; then
echo "No package specified"
exit_unlock
fi

if [ ! -f $PKGMDB ]; then
echo "Generate master database first by typing"
echo "$0 update"
echo "Otherwise load a database file by typing"
echo "$0 update loaddb [package db file]"
exit_unlock
fi


for pkg1 in $pkgnames
do

entry=`cat $PKGMDB | grep "|$pkg1|"`

pkgmatch=`echo "$entry" | cut -f 2 -d '|'`

	if [ "$entry" != "" ]; then
	
		if [ "$pkgmatch" == "$pkg1" ]; then
		
		details=`echo "$entry" | cut -f 10 -d '|'`
		pkgsize=`echo "$entry" | cut -f 6 -d '|'`
		numpkgsize=`echo $pkgsize | sed -e 's%K%%g'`
		pkgfilename=`echo "$entry" | cut -f 8 -d '|'`
		pkgsizemb=`expr $numpkgsize / 1024`
		installsize=`expr $numpkgsize \* 3`
		installsizemb=`expr $installsize / 1024`
		vers1=`echo "$entry" | cut -f 3 -d '|'`
		

		echo "Name: $pkg1"
		echo "Version: $vers1"
		echo "Details: $details"
		echo "Filename: $pkgfilename"
		echo "Package size: $pkgsize (${pkgsizemb}Mb)"
		echo "Approximate installed Size: ${installsizemb}Mb"

		subdeps=`echo "$entry" | cut -f 9 -d '|' | sed -e 's%&ge%_%g' | sed -e 's%&eq%_%g' | sed -e 's%&gt%_%g' | sed -e 's%,% %g'` 
		
		#subdeps=`echo "$subdeps" | sed -e 's%gtk2%gtk+2%g' | sed -e 's%gtk3%gtk+3%g' | sed -e 's%libstdc %libstdc++ %g'` 	
		
		subdeps2=""
		
			for d1 in $subdeps
			do
			
			d1=`echo "$d1" | sed -e 's#^+##g' | cut -f 1 -d '_'`
			
				if [ "$subdeps2" = "" ]; then
				subdeps2="$d1"
				else
				subdeps2="$subdeps2 $d1"
				fi
				
			done
		
			
			if [ "$subdeps" != "" ]; then			
				echo "Dependencies: $subdeps2"
			else
				echo "Dependencies: None"
			fi
			
		fi
			
	else
	echo "Package not found: $pkg1"
	fi

echo ""

done
	
}

process_packages(){
CNT=0
pkgnames=""

for pkg in $prepkgs
do
	if [ $CNT -gt 0 ] && [ "$pkg" != "" ]; then
		if [ "$pkgnames" != "" ]; then
		pkgnames="$pkgnames $pkg"
		else
		pkgnames="$pkg"
		fi
	fi

CNT=`expr $CNT + 1`

done




if [ "$pkgnames" == "" ]; then
echo "No package specified"
exit_unlock
fi

if [ ! -f $PKGMDB ]; then
echo "Generate master database first by typing"
echo "$0 update"
echo "Otherwise load a database file by typing"
echo "$0 update loaddb [package db file]"
exit_unlock
fi

mainpkg=""


for pkg1 in $pkgnames
do

echo "Searching $pkg1 from the database ..."

mainpkg="$pkg1"

entry=`cat $PKGMDB | grep "|$pkg1|"`

	if [ "$entry" != "" ]; then

	pkgmatch=`echo "$entry" | cut -f 2 -d '|'`
	
	if [ "$pkgmatch" == "$pkg1" ]; then
	
	pkgfilename1=`echo "$entry" | cut -f 8 -d '|'`
	pkgsize1=`echo "$entry" | cut -f 6 -d '|'`

	echo "$pkgfilename1|$pkgsize1|$mainpkg" >> /tmp/ppg-download-pkg

	subdeps=`echo "$entry" | cut -f 9 -d '|' | sed -e 's%&ge%_%g' | sed -e 's%&eq%_%g' | sed -e 's%&gt%_%g' | sed -e 's%,% %g'` 

		if [ "$subdeps" != "" ]; then
		echo "Searching dependencies for $pkg1 ..."
			for d1 in $subdeps
			do
			d1=`echo "$d1" | sed -e 's#^+##g' | cut -f 1 -d '_'`
			find_depends "$d1"
			done
		fi
		
	fi
		
	else
	echo "Package not found: $pkg1"
	fi

done

CNT8=1
totalsize=0

if [ -f /tmp/ppg-download-pkg ]; then

echo -e "\nThe following packages will be downloaded:"
	for d4 in `sort /tmp/ppg-download-pkg`
	do
	psize=$(echo "$d4" | cut -f 2 -d '|')
	numsize=`echo "$psize" | sed -e 's%K%%g'`
	echo "$CNT8. $(echo "$d4" | cut -f 1 -d '|') ($psize)"
	CNT8=`expr $CNT8 + 1`
	totalsize=`expr $totalsize + $numsize`
	done

diskspace=`expr $totalsize \* 3`

get_free_disk_space

#SIZEFREEM=`cat /tmp/pup_event_sizefreem | head -n 1` #100821 bug in Lucid 5.1, file had two identical lines.
FREEMEMK=`expr $SIZEFREEM \* 1024`

echo -e "\nPackages to install: $(expr $CNT8 - 1)"
echo "Total download size: $(expr $totalsize / 1024)Mb"
echo "Approximate disk space needed for installation: $(expr $diskspace / 1024)Mb" 

if [ $totalsize -gt $FREEMEMK ]; then
echo -e "\nYou need more disk space to download the following packages"
clean_temp_file
exit_unlock
elif [ $diskspace -gt $FREEMEMK ]; then
echo -e "\nYou need more disk space to install the following packages"
clean_temp_file
exit_unlock
fi

echo -e "\nPress any key to continue or type 'x' to exit"
read resp

if [ "$resp" == "x" ] || [ "$resp" == "X" ]; then
echo ""
clean_temp_file
exit_unlock
fi

else
clean_temp_file
exit_unlock	
fi

build_repo

for dl in `cat /tmp/ppg-download-pkg`
do
download_pkgs "$(echo "$dl" | cut -f 1 -d '|')"
done

if [ "$mcommand" == "install" ] && [ -s /tmp/ppg-success ]; then
install_pkgs
fi

sleep 1

if [ -s /tmp/ppg-desktop-files ]; then
menufix
fi

if [ -s /tmp/ppg-success ]; then

if [ "$mcommand" == "install" ]; then
	echo -e "\nPress any key to purge downloaded package or type 'x' to keep the packages"
	read resp
else
resp="x"
fi

	if [ "$resp" == "x" ] || [ "$resp" == "X" ]; then
	
	 if [ "$mcommand" == "install" ]; then
	 echo "Downloaded packages not deleted"
	 fi
	
	DELPKG=0
	else	
	DELPKG=1
	fi
	
	for pg in `cat /tmp/ppg-success`
	do
		if [ $DELPKG -eq 0 ]; then
		  locpkg=`basename $pg`
		  TPKG=`cat /tmp/ppg-download-pkg | grep "$locpkg" | cut -f 3 -d '|'`
			if [ "$TPKG" != "" ]; then
			  echo "Moving $(basename $pg) to $DL_PATH/$TPKG..."	
			   if [ ! -d $DL_PATH/$TPKG ]; then
				mkdir $DL_PATH/$TPKG
			   fi
			  mv -f $pg $DL_PATH/$TPKG/
			fi	
		else
		 echo "Deleting $(basename $pg) ..."
		 rm -f $pg
		fi	
		sleep 1
	done
	
fi

DLGOOD=0

if [ -s /tmp/ppg-success ]; then
DLGOOD=`cat /tmp/ppg-success | wc -l`
fi

DLBAD=0

if [ -s /tmp/ppg-failed ]; then
DLBAD=`cat /tmp/ppg-failed | wc -l`
fi

PGOOD=0

if [ -s /tmp/ppg-install-pkg-good ]; then
PGOOD=`cat /tmp/ppg-install-pkg-good  | wc -l`
fi

PBAD=0

if [ -s /tmp/ppg-install-pkg-bad ]; then
PBAD=`cat /tmp/ppg-install-pkg-bad  | wc -l`
fi

echo ""
echo "***** Report Summary *****"
echo "Download packages sucess: $DLGOOD"
echo "Download packages failed: $DLBAD"
echo "Packages sucessfully installed: $PGOOD"
echo "Packages failed to install: $PBAD"

}

listdb(){

if [ ! -f $PKGMDB ]; then
echo "Generate master database first by typing"
echo "$0 update"
echo "Otherwise load a database file by typing"
echo "$0 update loaddb [package db file]"
exit_unlock
fi

while IFS='' read -r line || [[ -n $line ]]
do
	if [ "$line" != "" ]; then
	echo $line | cut -f 2 -d '|'
	fi
done < $PKGMDB
	
}

install_func(){
export LANG=C
. /etc/xdg/menus/hierarchy #w478 has PUPHIERARCHY variable.

[ "$PUPMODE" = "2" ] && [ ! -d /audit ] && mkdir -p /audit

DLPKG="$1"
DLPKG_BASE="`basename "$DLPKG"`" #ex: scite-1.77-i686-2as.tgz
DLPKG_PATH="`dirname "$DLPKG"`"  #ex: /root

case $DLPKG_BASE in
	 *.pet)
	DLPKG_NAME=`basename $DLPKG_BASE .pet`
	;;
	 *.deb)
	DLPKG_NAME=`basename $DLPKG_BASE .deb` 
	;;
	 *.tgz)
	DLPKG_NAME=`basename $DLPKG_BASE .tgz` 
	;;
	 *.txz)
	DLPKG_NAME=`basename $DLPKG_BASE .txz`
	;;
	 *.rpm)
	DLPKG_NAME=`basename $DLPKG_BASE .rpm` 
	;;
	 *.tar.gz)
	DLPKG_NAME=`basename $DLPKG_BASE .tar.gz`
	;;
	 *.tar.bz2)
	DLPKG_NAME=`basename $DLPKG_BASE .tar.bz2` 
	;;
	 *.pkg.tar.xz) 
	DLPKG_NAME=`basename $DLPKG_BASE .pkg.tar.xz`
    ;;
     *.pkg.tar.gz) 
	DLPKG_NAME=`basename $DLPKG_BASE .pkg.tar.gz`
	;;
esac

PKGMAIN="$DLPKG_NAME"

PKGSIZEB=`stat --format=%s "${DLPKG_PATH}"/${DLPKG_BASE}`
PKGSIZEK=`expr $PKGSIZEB \/ 1024`

#echo "$DLPKG_NAME" 

#131222 do not allow duplicate installs...
PTN1='^'"$DLPKG_NAME"'|'
if [ "`grep "$PTN1" /root/.packages/user-installed-packages`" != "" ];then
  echo "$(gettext 'This package is already installed. Cannot install it twice:') ${DLPKG_BASE}"
 return 1
fi

case $DLPKG_BASE in
  *.deb)
   #deb ex: xsltproc_1.1.24-1ubuntu2_i386.deb  xserver-common_1.5.2-2ubuntu3_all.deb
   DB_nameonly="`echo -n "$PKGMAIN" | cut -f 1 -d '_'`"
   DB_pkgrelease="`echo -n "$PKGMAIN" | rev | cut -f 2 -d '_' | cut -f 1 -d '-' | rev`"
   prPATTERN="s%\-${DB_pkgrelease}.*%%"
   PKGNAME="`echo -n "$PKGMAIN" | sed -e "$prPATTERN"`"
   DB_version="`echo "$PKGNAME" | cut -f 2 -d '_'`"
  ;;
  *.pet)
   PKGNAME="$PKGMAIN"
   DB_version="`echo -n "$PKGNAME" | grep -o '\-[0-9].*' | sed -e 's%^\-%%'`"
   xDB_version="`echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g'`"
   xPATTERN="s%${xDB_version}%%"
   DB_nameonly="`echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%'`"
   DB_pkgrelease=""
  ;;
  *.tgz)
   #slack ex: xvidtune-1.0.1-i486-1.tgz  printproto-1.0.4-noarch-1.tgz
   PKGNAME="`echo -n "$PKGMAIN" | sed -e 's%\-i[3456]86.*%%' -e 's%\-noarch.*%%'`"
   DB_version="`echo -n "$PKGNAME" | grep -o '\-[0-9].*' | sed -e 's%^\-%%'`"
   xDB_version="`echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g'`"
   xPATTERN="s%${xDB_version}%%"
   DB_nameonly="`echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%'`"
   DB_pkgrelease="`echo -n "$PKGMAIN" | sed -e 's%.*\-i[3456]86%%' -e 's%.*\-noarch%%' -e 's%^\-%%'`"
  ;;
  *.txz)
   #slack ex: xvidtune-1.0.1-i486-1.tgz  printproto-1.0.4-noarch-1.tgz
   PKGNAME="`echo -n "$PKGMAIN" | sed -e 's%\-i[3456]86.*%%' -e 's%\-noarch.*%%'`"
   DB_version="`echo -n "$PKGNAME" | grep -o '\-[0-9].*' | sed -e 's%^\-%%'`"
   xDB_version="`echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g'`"
   xPATTERN="s%${xDB_version}%%"
   DB_nameonly="`echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%'`"
   DB_pkgrelease="`echo -n "$PKGMAIN" | sed -e 's%.*\-i[3456]86%%' -e 's%.*\-noarch%%' -e 's%^\-%%'`"
  ;;
  *.pkg.tar.gz)
   #arch ex: xproto-7.0.14-1-i686.pkg.tar.gz  trapproto-3.4.3-1.pkg.tar.gz
   PKGNAME="`echo -n "$PKGMAIN" | sed -e 's%\-i[3456]86.*%%' -e 's%\.pkg$%%' | rev | cut -f 2-9 -d '-' | rev`"
   DB_version="`echo -n "$PKGNAME" | grep -o '\-[0-9].*' | sed -e 's%^\-%%'`"
   xDB_version="`echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g'`"
   xPATTERN="s%${xDB_version}%%"
   DB_nameonly="`echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%'`"
   DB_pkgrelease="`echo -n "$PKGMAIN" | sed -e 's%\-i[3456]86.*%%' -e 's%\.pkg$%%' | rev | cut -f 1 -d '-' | rev`"
  ;;
  *.pkg.tar.xz)
   #arch ex: xproto-7.0.14-1-i686.pkg.tar.gz  trapproto-3.4.3-1.pkg.tar.gz
   PKGNAME="`echo -n "$PKGMAIN" | sed -e 's%\-i[3456]86.*%%' -e 's%\.pkg$%%' | rev | cut -f 2-9 -d '-' | rev`"
   DB_version="`echo -n "$PKGNAME" | grep -o '\-[0-9].*' | sed -e 's%^\-%%'`"
   xDB_version="`echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g'`"
   xPATTERN="s%${xDB_version}%%"
   DB_nameonly="`echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%'`"
   DB_pkgrelease="`echo -n "$PKGMAIN" | sed -e 's%\-i[3456]86.*%%' -e 's%\.pkg$%%' | rev | cut -f 1 -d '-' | rev`"
  ;;
  *.rpm) #110523
   #exs: hunspell-fr-3.4-1.1.el6.noarch.rpm
   PKGNAME="$PKGMAIN"
   DB_version="`echo -n "$PKGNAME" | grep -o '\-[0-9].*' | sed -e 's%^\-%%'`"
   xDB_version="`echo -n "$DB_version" | sed -e 's%\\-%\\\\-%g' -e 's%\\.%\\\\.%g'`"
   xPATTERN="s%${xDB_version}%%"
   DB_nameonly="`echo -n "$PKGNAME" | sed -e "$xPATTERN" -e 's%\-$%%'`"
   DB_pkgrelease=""
  ;;
esac


#boot from flash: bypass tmpfs top layer, install direct to pup_save file...
DIRECTSAVEPATH=""
 
if [ "$PUPMODE" = "2" ]; then # from BK's quirky6.1

#131220  131229 detect if not enough room in /tmp...
DIRECTSAVEPATH=""
EXPK=`expr $PKGSIZEK \* 3` #estimated worst-case expanded size.
NEEDK=$EXPK
TMPK=`df -k /tmp | grep '^tmpfs' | tr -s ' ' | cut -f 4 -d ' '` #free space in /tmp
if [ $EXPK -ge $TMPK ];then
  DIRECTSAVEPATH="/audit/directsavepath"
  NEEDK=`expr $NEEDK \* 2`
fi
if [ "$DIRECTSAVEPATH" ];then
 rm -rf $DIRECTSAVEPATH
 mkdir -p $DIRECTSAVEPATH
fi

# check enough space to install pkg...
#as the pkg gets expanded to an intermediate dir, maybe in main f.s...
PARTK=`df -k / | grep '/$' | tr -s ' ' | cut -f 4 -d ' '` #free space in partition.
if [ $NEEDK -gt $PARTK ];then
  echo -e "$(gettext 'Not enough free space in the partition to install this package'): ${DLPKG_BASE}"
 #[ "$DLPKG_PATH" != "" ] && rm -f "${DLPKG_PATH}"/${DLPKG_BASE}
 return 1
fi

#111013 shinobar: this currently not working, bypass for now... 111013 revert...
#elif [ "ABC" = "DEF" ];then #111013
elif [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then

get_free_disk_space

#SIZEFREEM=`cat /tmp/pup_event_sizefreem | head -n 1` #100821 bug in Lucid 5.1, file had two identical lines.
TMPK=`expr $SIZEFREEM \* 1024`
EXPK=`expr $PKGSIZEK \* 3` #estimated worst-case expanded size.
NEEDK=$EXPK

if [ $EXPK -ge $TMPK ];then
  NEEDK=`expr $NEEDK \* 2`
fi

if [ $NEEDK -gt $TMPK ];then
  echo -e "$(gettext 'Not enough free space to install this package'): ${DLPKG_BASE}"
 #[ "$DLPKG_PATH" != "" ] && rm -f "${DLPKG_PATH}"/${DLPKG_BASE}
 return 1
fi

  # SFR: let user chose...
  #[ -f /var/local/petget/install_mode ] && IMODE="`cat /var/local/petget/install_mode`" || IMODE="savefile"
  IMODE="savefile"
  if [ "$IMODE" != "tmpfs" ]; then
    FLAGNODIRECT=1
    #100426 aufs can now write direct to save layer...
    #note: fsnotify now preferred not inotify, udba=notify uses whichever is enabled in module...
    busybox mount -t aufs -o remount,udba=notify unionfs / #remount aufs with best evaluation mode.
    FLAGNODIRECT=$?
    [ $FLAGNODIRECT -ne 0 ] && logger -s -t "installpkg.sh" "Failed to remount aufs / with udba=notify"
    if [ $FLAGNODIRECT -eq 0 ];then
     #note that /sbin/pup_event_frontend_d will not run snapmergepuppy if installpkg.sh or downloadpkgs.sh are running.
     while [ "`pidof snapmergepuppy`" != "" ];do
      sleep 1
     done
     DIRECTSAVEPATH="/initrd${SAVE_LAYER}" #SAVE_LAYER is in /etc/rc.d/PUPSTATE.
     rm -f $DIRECTSAVEPATH/pet.specs $DIRECTSAVEPATH/pinstall.sh $DIRECTSAVEPATH/puninstall.sh $DIRECTSAVEPATH/install/doinst.sh
    fi
  fi
fi

echo "Installing $DLPKG_BASE ..."

cd "$DLPKG_PATH"

INSTALL_SUCESS=0

#Extract Packages

ext_type=""


case $DLPKG_BASE in
 *.pet)
  ext_type="pet"
  # determine compression
  file -b "$DLPKG_BASE" | grep -i -q "^xz" && EXT=xz || EXT=gz #131122 #140109 add -i, eg: "XZ"
  case $EXT in
  xz)OPT=-J ;;
  gz)OPT=-z ;;
  esac
  DLPKG_MAIN="`basename $DLPKG_BASE .pet`"
  cp -f $DLPKG_BASE base-$DLPKG_BASE
  pet2tgz $DLPKG_BASE
  retval=$?
  mv -f base-$DLPKG_BASE $DLPKG_BASE
  [ $retval -ne 0 ] && return 1
  PETFILES="`tar --list ${OPT} -f ${DLPKG_MAIN}.tar.${EXT}`"
  #slackware pkg, got a case where passed the above test but failed here...
  [ $? -ne 0 ] && return 1
  #check for renamed pets. Will produce an empty ${DLPKG_NAME}.files file
  PETFOLDER=$(echo "${PETFILES}" | cut -f 2 -d '/' | head -n 1)
  [ "$PETFOLDER" = "" ] && PETFOLDER=$(echo "${PETFILES}" | cut -f 1 -d '/' | head -n 1)
  
  if [ "${DLPKG_MAIN}" != "${PETFOLDER}" ]; then
   echo "$DLPKG_MAIN.pet $(gettext 'is named') $PETFOLDER $(gettext 'inside the pet file. Will not install it!')"
   return 1
  fi
  
  if [ "`echo "$PETFILES" | grep '^\\./'`" != "" ];then
   #ttuuxx has created some pets with './' prefix...
   pPATTERN="s%^\\./${DLPKG_NAME}%%"
   echo "$PETFILES" | sed -e "$pPATTERN" > $PKGFILEPATH/${DLPKG_NAME}.files
   
   install_path_check
   
   tar ${OPT} -x -h --strip=2 --directory=${DIRECTSAVEPATH}/ -f ${DLPKG_MAIN}.tar.${EXT} #120102. 120107 remove --unlink-first
  
  else
   #new2dir and tgz2pet creates them this way...
   pPATTERN="s%^${DLPKG_NAME}%%"
   echo "$PETFILES" | sed -e "$pPATTERN" > $PKGFILEPATH/${DLPKG_NAME}.files
   
   install_path_check
   
   tar ${OPT} -x -h --strip=1 --directory=${DIRECTSAVEPATH}/ -f ${DLPKG_MAIN}.tar.${EXT} #120102. 120107. 131122
   
  fi
  
  if [ $? -ne 0 ]; then
  clean_and_die
  return 1
  fi 
 ;;
 
 *.deb)
  ext_type="deb"
  DLPKG_MAIN="`basename $DLPKG_BASE .deb`"
  PFILES="`dpkg-deb --contents $DLPKG_BASE | tr -s ' ' | cut -f 6 -d ' '`"
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  dpkg-deb -x $DLPKG_BASE ${DIRECTSAVEPATH}/
  [ $? -ne 0 ] && clean_and_die
  [ -d /DEBIAN ] && rm -rf /DEBIAN #130112 precaution.
  dpkg-deb -e $DLPKG_BASE /DEBIAN #130112 extracts deb control files to dir /DEBIAN. may have a post-install script, see below.
  write_deb_spec
 ;;
 
 *.tgz)
  ext_type="tgz"
  DLPKG_MAIN="`basename $DLPKG_BASE .tgz`" #ex: scite-1.77-i686-2as
  gzip --test $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`tar --list -z -f $DLPKG_BASE`"
  #hmmm, got a case where passed the above test but failed here...
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
   
   install_path_check

   tar -z -x -h --directory=${DIRECTSAVEPATH}/ -f $DLPKG_BASE #120102. 120107
  
  if [ $? -ne 0 ]; then
  clean_and_die
  return 1
  fi 
  
  write_slack_spec
  
 ;;
 
 *.txz) #100616
  ext_type="txz"
  DLPKG_MAIN="`basename $DLPKG_BASE .txz`" #ex: scite-1.77-i686-2as
  xz --test $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`tar --list -J -f $DLPKG_BASE`"
  #hmmm, got a case where passed the above test but failed here...
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  
  tar -J -x -h --directory=${DIRECTSAVEPATH}/ -f $DLPKG_BASE #120102. 120107
  
  if [ $? -ne 0 ]; then
  clean_and_die
  return 1
  fi
  
  write_slack_spec
  
 ;;
 
 *.tar.gz)
  ext_type="tar.gz"
  DLPKG_MAIN="`basename $DLPKG_BASE .tar.gz`" #ex: acl-2.2.47-1-i686.pkg
  gzip --test $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`tar --list -z -f $DLPKG_BASE`"
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  
  tar -z -x -h --directory=${DIRECTSAVEPATH}/ -f $DLPKG_BASE #120102. 120107
  
  if [ $? -ne 0 ]; then
  clean_and_die
  return 1
  fi
 ;;
 
  *.pkg.tar.gz)
  ext_type="pkg.tar.gz"
  DLPKG_MAIN="`basename $DLPKG_BASE .pkg.tar.gz`" #ex: acl-2.2.47-1-i686.pkg
  gzip --test $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`tar --list -z -f $DLPKG_BASE`"
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  
  tar -z -x -h --directory=${DIRECTSAVEPATH}/ -f $DLPKG_BASE #120102. 120107
  
  if [ $? -ne 0 ]; then
  clean_and_die
  fi
  
  if [ -f /.BUILDINFO ]; then
  rm -f /.BUILDINFO
  fi
  
  if [ -f /.MTREE ]; then
  rm -f /.MTREE
  fi
  
  write_arch_spec
  
  if [ -f /.PKGINFO ]; then
  rm -f /.PKGINFO
  fi
  
  return 1
  
 ;;
 
 *.tar.bz2) #100110
  ext_type="tar.bz2"
  DLPKG_MAIN="`basename $DLPKG_BASE .tar.bz2`"
  bzip2 --test $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`tar --list -j -f $DLPKG_BASE`"
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  
  tar -j -x -h --directory=${DIRECTSAVEPATH}/ -f $DLPKG_BASE #120102. 120107
  
  if [ $? -ne 0 ]; then
  clean_and_die
  return 1
  fi
 ;;
 
 *.pkg.tar.xz) #130314 arch pkgs.
  ext_type="pkg.tar.xz"
  DLPKG_MAIN="`basename $DLPKG_BASE .pkg.tar.xz`" #ex: acl-2.2.51-3-i686
  xz --test $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`tar --list -J -f $DLPKG_BASE`"
  #hmmm, got a case where passed the above test but failed here...
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  
  tar -J -x -h --directory=${DIRECTSAVEPATH}/ -f $DLPKG_BASE
  
  if [ $? -ne 0 ]; then
  clean_and_die
  fi
  
  if [ -f /.BUILDINFO ]; then
  rm -f /.BUILDINFO
  fi
  
  if [ -f /.MTREE ]; then
  rm -f /.MTREE
  fi
  
  write_arch_spec
  
  if [ -f /.PKGINFO ]; then
  rm -f /.PKGINFO
  fi
  
  return 1
  
 ;;
 
 *.rpm) #110523
  ext_type="rpm"
  DLPKG_MAIN="`basename $DLPKG_BASE .rpm`"
  busybox rpm -qp $DLPKG_BASE > /dev/null 2>&1
  [ $? -ne 0 ] && return 1
  PFILES="`busybox rpm -qpl $DLPKG_BASE`"
  [ $? -ne 0 ] && return 1
  echo "$PFILES" > $PKGFILEPATH/${DLPKG_NAME}.files
  install_path_check
  #110705 rpm -i does not work for mageia pkgs...
  exploderpm -i $DLPKG_BASE
  
  if [ $? -ne 0 ]; then
  clean_and_die
  return 1
  fi
  
  busybox rpm -qpi $DLPKG_BASE > /rpm-info
  write_rpm_spec
  
 ;;
esac


if [ "$PUPMODE" = "2" ]; then #from BK's quirky6.1
 mkdir /audit/${DLPKG_NAME}-DEPOSED
 echo -n '' > /tmp/ppg-FLAGFND
 find ${DIRECTSAVEPATH}/ -mindepth 1 | sed -e "s%${DIRECTSAVEPATH}%%" |
 while read AFILESPEC
 do
  if [ -f "$AFILESPEC" ];then
   ADIR="$(dirname "$AFILESPEC")"
   mkdir -p /audit/${DLPKG_NAME}-DEPOSED/${ADIR}
   cp -a -f "$AFILESPEC" /audit/${DLPKG_NAME}-DEPOSED/${ADIR}/
   echo -n '1' > /tmp/ppg-FLAGFND
  fi
 done
 sync
 if [ -s /tmp/ppg-FLAGFND ];then
  [ -f /audit/${DLPKG_NAME}-DEPOSED.sfs ] && rm -f /audit/${DLPKG_NAME}-DEPOSED.sfs #precaution, should not happen, as not allowing duplicate installs of same pkg.
  mksquashfs /audit/${DLPKG_NAME}-DEPOSED /audit/${DLPKG_NAME}-DEPOSED.sfs
 fi
 sync
 rm -rf /audit/${DLPKG_NAME}-DEPOSED
 #now write temp-location to final destination...
 cp -a -f --remove-destination ${DIRECTSAVEPATH}/* /  2> /tmp/ppg-errlog
 sync
 #can have a problem if want to replace a folder with a symlink. for example, got this error:
 # cp: cannot overwrite directory '/usr/share/mplayer/skins' with non-directory
 #3builddistro has this fix... which is a vice-versa situation...
 #firstly, the vice-versa, source is a directory, target is a symlink...
 CNT=0
 while [ -s /tmp/ppg-errlog ];do
  echo -n '' > /tmp/ppg-errlog2
  echo -n '' > /tmp/ppg-errlog3
  cat /tmp/ppg-errlog | grep 'cannot overwrite non-directory' | grep 'with directory' | tr '[`‘’]' "'" | cut -f 2 -d "'" |
  while read ONEDIRSYMLINK #ex: /usr/share/mplayer/skins
  do
   if [ -h "${ONEDIRSYMLINK}" ];then #source is a directory, target is a symlink...
    #adding that extra trailing / does the trick...
    cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}"/* "${ONEDIRSYMLINK}"/ 2>> /tmp/ppg-errlog2
   else #source is a directory, target is a file...
    rm -f "${ONEDIRSYMLINK}" #delete the file!
    DIRPATH="$(dirname "${ONEDIRSYMLINK}")"
    cp -a -f ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}" "${DIRPATH}"/ 2>> /tmp/ppg-errlog2 #copy directory (and contents).
   fi
  done
  #secondly, which is our mplayer example, source is a symlink, target is a folder...
  cat /tmp/ppg-errlog | grep 'cannot overwrite directory' | grep 'with non-directory' | tr '[`‘’]' "'" | cut -f 2 -d "'" |
  while read ONEDIRSYMLINK #ex: /usr/share/mplayer/skins
  do
   #difficult situation, whether to impose the symlink of package, or not. if not...
   #cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}"/* "${ONEDIRSYMLINK}"/ 2> /tmp/ppg-errlog3
   #or, if we have chosen to follow link...
   DIRPATH="$(dirname "${ONEDIRSYMLINK}")"
   if [ -h ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}" ];then #source is a symlink, trying to overwrite a directory...
    ALINK="$(readlink ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}")"
    if [ "${ALINK:0:1}" = "/" ];then #test 1st char
     xALINK="$ALINK" #absolute
    else
     xALINK="${DIRPATH}/${ALINK}"
    fi
    if [ -d "$xALINK" ];then
     cp -a -f --remove-destination "${ONEDIRSYMLINK}"/* "$xALINK"/ 2>> /tmp/ppg-errlog3 #relocates target files.
     rm -rf "${ONEDIRSYMLINK}"
     cp -a -f ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}" "${DIRPATH}"/ #creates symlink only.
    fi
   else #source is a file, trying to overwrite a directory...
    rm -rf "${ONEDIRSYMLINK}" #deleting directory!!!
    cp -a -f ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}" "${DIRPATH}"/ #creates file only.
   fi
  done
  cat /tmp/ppg-errlog2 >> /tmp/ppg-errlog3
  cat /tmp/ppg-errlog3 > /tmp/ppg-errlog
  sync
  CNT=`expr $CNT + 1`
  [ $CNT -gt 10 ] && break #something wrong, get out.
 done

 #end 131220
 rm -rf ${DIRECTSAVEPATH} #131229 131230

#[ "$DL_SAVE_FLAG" != "true" ] && rm -f $DLPKG_BASE 2>/dev/null
rm -f $DLPKG_MAIN.tar.gz 2>/dev/null

#pkgname.files may need to be fixed...
FIXEDFILES="`cat $PKGFILEPATH/${DLPKG_NAME}.files | grep -v '^\\./$'| grep -v '^/$' | sed -e 's%^\\.%%' -e 's%^%/%' -e 's%^//%/%'`"
echo "$FIXEDFILES" > $PKGFILEPATH/${DLPKG_NAME}.files 

else


#[ "$DL_SAVE_FLAG" != "true" ] &&  rm -f $DLPKG_BASE 2>/dev/null
rm -f $DLPKG_MAIN.tar.${EXT} 2>/dev/null #131122

#pkgname.files may need to be fixed...
FIXEDFILES="`cat $PKGFILEPATH/${DLPKG_NAME}.files | grep -v '^\\./$'| grep -v '^/$' | sed -e 's%^\\.%%' -e 's%^%/%' -e 's%^//%/%'`"
echo "$FIXEDFILES" > $PKGFILEPATH/${DLPKG_NAME}.files

#120102 install may have overwritten a symlink-to-dir...
#tar defaults to not following symlinks, for both dirs and files, but i want to follow symlinks
#for dirs but not for files. so, fix here... (note, dir entries in .files have / on end)
cat $PKGFILEPATH/${DLPKG_NAME}.files | grep '[a-zA-Z0-9]/$' | sed -e 's%/$%%' | grep -v '^/mnt' |
while read ONESPEC
do
 if [ -d "${DIRECTSAVEPATH}${ONESPEC}" ];then
  if [ ! -h "${DIRECTSAVEPATH}${ONESPEC}" ];then
   DIRLINK=""
   if [ -h "/initrd${PUP_LAYER}${ONESPEC}" ];then #120107
    DIRLINK="`readlink -m "/initrd${PUP_LAYER}${ONESPEC}" | sed -e "s%/initrd${PUP_LAYER}%%"`" #PUP_LAYER: see /etc/rc.d/PUPSTATE. 120107
    xDIRLINK="`readlink "/initrd${PUP_LAYER}${ONESPEC}"`" #120107
   fi
   if [ ! "$DIRLINK" ];then
    if [ -h "/initrd${SAVE_LAYER}${ONESPEC}" ];then #120107
     DIRLINK="`readlink -m "/initrd${SAVE_LAYER}${ONESPEC}" | sed -e "s%/initrd${SAVE_LAYER}%%"`" #SAVE_LAYER: see /etc/rc.d/PUPSTATE. 120107
     xDIRLINK="`readlink "/initrd${SAVE_LAYER}${ONESPEC}"`" #120107
    fi
   fi
   if [ "$DIRLINK" ];then
    if [ -d "$DIRLINK"  ];then
     if [ "$DIRLINK" != "${ONESPEC}" ];then #precaution.
      mkdir -p "${DIRECTSAVEPATH}${DIRLINK}" #120107
      cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONESPEC}"/* "${DIRECTSAVEPATH}${DIRLINK}/" #ha! fails if put double-quotes around entire expression.
      rm -rf "${DIRECTSAVEPATH}${ONESPEC}"
      if [ "$DIRECTSAVEPATH" = "" ];then
       ln -s "$xDIRLINK" "${ONESPEC}"
      else
       DSOPATH="`dirname "${DIRECTSAVEPATH}${ONESPEC}"`"
       DSOBASE="`basename "${DIRECTSAVEPATH}${ONESPEC}"`"
       rm -f "${DSOPATH}/.wh.${DSOBASE}" #allow underlying symlink to become visible on top.
      fi
     fi
    fi
   fi
  fi
 fi
done

#121217 it seems that this problem is occurring in other modes (13 reported)...
#121123 having a problem with multiarch symlinks in full-installation...
#it seems that the symlink is getting replaced by a directory.
if [ "$DISTRO_ARCHDIR" ];then #in /etc/rc.d/DISTRO_SPECS. 130112 change test from DISTRO_ARCHDIR. 130114 revert DISTRO_ARCHDIR_SYMLINKS==yes.
  if [ -d /usr/lib/${DISTRO_ARCHDIR} ];then
   if [ ! -h /usr/lib/${DISTRO_ARCHDIR} ];then
    cp -a -f --remove-destination /usr/lib/${DISTRO_ARCHDIR}/* /usr/lib/
    sync
    rm -r -f /usr/lib/${DISTRO_ARCHDIR}
    ln -s ./ /usr/lib/${DISTRO_ARCHDIR}
   fi
  fi
  if [ -d /lib/${DISTRO_ARCHDIR} ];then
   if [ ! -h /lib/${DISTRO_ARCHDIR} ];then
    cp -a -f --remove-destination /lib/${DISTRO_ARCHDIR}/* /lib/
    sync
    rm -r -f /lib/${DISTRO_ARCHDIR}
    ln -s ./ /lib/${DISTRO_ARCHDIR}
   fi
  fi
  if [ -d /usr/bin/${DISTRO_ARCHDIR} ];then
   if [ ! -h /usr/bin/${DISTRO_ARCHDIR} ];then
    cp -a -f --remove-destination /usr/bin/${DISTRO_ARCHDIR}/* /usr/bin/
    sync
    rm -r -f /usr/bin/${DISTRO_ARCHDIR}
    ln -s ./ /usr/bin/${DISTRO_ARCHDIR}
   fi
  fi
fi

#flush unionfs cache, so files in pup_save layer will appear "on top"...
if [ "$DIRECTSAVEPATH" != "" ];then
 #but first, clean out any bad whiteout files...
 # 22sep10 shinobar: bugfix was not working clean out whiteout files
 find /initrd/pup_rw -mount -type f -name .wh.\*  -printf '/%P\n'|
 while read ONEWHITEOUT
 do
  ONEWHITEOUTFILE="`basename "$ONEWHITEOUT"`"
  ONEWHITEOUTPATH="`dirname "$ONEWHITEOUT"`"
  if [ "$ONEWHITEOUTFILE" = ".wh.__dir_opaque" ];then
   [ "`grep "$ONEWHITEOUTPATH" $PKGFILEPATH/${DLPKG_NAME}.files`" != "" ] && rm -f "/initrd/pup_rw/$ONEWHITEOUT"
   continue
  fi
  ONEPATTERN="`echo -n "$ONEWHITEOUT" | sed -e 's%/\\.wh\\.%/%'`"'/*'	;#echo "$ONEPATTERN" >&2
  [ "`grep -x "$ONEPATTERN" $PKGFILEPATH/${DLPKG_NAME}.files`" != "" ] && rm -f "/initrd/pup_rw/$ONEWHITEOUT"
 done
 #111229 /usr/local/petget/removepreview.sh when uninstalling a pkg, may have copied a file from sfs-layer to top, check...
 cat $PKGFILEPATH/${DLPKG_NAME}.files |
 while read ONESPEC
 do
  [ "$ONESPEC" = "" ] && continue #precaution.
  if [ ! -d "$ONESPEC" ];then
   [ -e "/initrd/pup_rw${ONESPEC}" ] && rm -f "/initrd/pup_rw${ONESPEC}"
  fi
 done
 #now re-evaluate all the layers...
 busybox mount -t aufs -o remount,udba=reval unionfs / #remount with faster evaluation mode.
 [ $? -ne 0 ] && logger -s -t "installpkg.sh" "Failed to remount aufs / with udba=reval"

 sync
fi

fi

#some .pet pkgs have images at '/'...
mv /*24.xpm /usr/local/lib/X11/pixmaps/ 2>/dev/null
mv /*32.xpm /usr/local/lib/X11/pixmaps/ 2>/dev/null
mv /*32.png /usr/local/lib/X11/pixmaps/ 2>/dev/null
mv /*48.xpm /usr/local/lib/X11/pixmaps/ 2>/dev/null
mv /*48.png /usr/local/lib/X11/pixmaps/ 2>/dev/null
mv /*.xpm /usr/local/lib/X11/mini-icons/ 2>/dev/null
mv /*.png /usr/local/lib/X11/mini-icons/ 2>/dev/null

ls -dl /tmp | grep -q '^drwxrwxrwt' || chmod 1777 /tmp #130305 rerwin.

#post-install script?...
if [ -f /pinstall.sh ];then #pet pkgs.
 chmod +x /pinstall.sh
 cd /
  LANG=$LANG_USER nohup sh /pinstall.sh &
  sleep 0.2
 rm -f /pinstall.sh
fi

if [ -f /install/doinst.sh ];then #slackware pkgs.
 chmod +x /install/doinst.sh
 cd /
 LANG=$LANG_USER nohup sh /install/doinst.sh &
 sleep 0.2
 rm -rf /install
else
rm -rf /install
fi

if [ -e /DEBIAN/postinst ];then #130112 deb post-install script.
 cd /
 LANG=$LANG_USER nohup sh DEBIAN/postinst &
 sleep 0.2
 rm -rf /DEBIAN
else
rm -rf /DEBIAN
fi

#130314 run arch linux pkg post-install script...
if [ -f /.INSTALL ];then #arch post-install script.
 if [ -f /usr/local/petget/ArchRunDotInstalls ];then #precaution. see 3builddistro, script created by noryb009.
  #this code is taken from below...
  dlPATTERN='|'"`echo -n "$DLPKG_BASE" | sed -e 's%\\-%\\\\-%'`"'|'
  archVER="`cat $PKGMDB | grep "$dlPATTERN" | head -n 1 | cut -f 3 -d '|'`"
  if [ "$archVER" ];then #precaution.
   cd /
   mv -f .INSTALL .INSTALL1-${archVER}
   cp -a /usr/local/petget/ArchRunDotInstalls /ArchRunDotInstalls
   LANG=$LANG_USER /ArchRunDotInstalls
   rm -f ArchRunDotInstalls
   rm -f .INSTALL*
  fi
 fi
fi

#v424 .pet pkgs may have a post-uninstall script...
if [ -f /puninstall.sh ];then
 mv -f /puninstall.sh $PKGRMSCRIPT/${DLPKG_NAME}.remove
fi

#w465 <pkgname>.pet.specs is in older pet pkgs, just dump it...
#maybe a '$APKGNAME.pet.specs' file created by dir2pet script...
rm -f /*.pet.specs 2>/dev/null
#retval=$?

#...note, this has a setting to prevent .files and entry in user-installed-packages, so install not registered.

if [ ! -f /pet.specs ]; then    
    echo "${DLPKG_NAME}|$DB_nameonly|$DB_version|$DB_pkgrelease||${PKGSIZEK}K||${DLPKG_BASE}|||" > /pet.specs
fi

#add entry to /root/.packages/user-installed-packages...
#w465 a pet pkg may have /pet.specs which has a db entry...
if [ -f /pet.specs -a -s /pet.specs ];then #w482 ignore zero-byte file.
 DB_ENTRY="`cat /pet.specs | head -n 1`"
 #DLPKG_NAME=`echo "$DB_ENTRY" | cut -f 1 -d '|'`
 rm -f /pet.specs
else
 [ -f /pet.specs ] && rm -f /pet.specs #w482 remove zero-byte file.
 dlPATTERN='|'"`echo -n "$DLPKG_BASE" | sed -e 's%\\-%\\\\-%'`"'|'
 DB_ENTRY="`cat /pet.specs | grep "$dlPATTERN" | head -n 1`"
 #DLPKG_NAME=`echo "$DB_ENTRY" | cut -f 1 -d '|'`
fi

##+++2011-12-27 KRG check if $DLPKG_BASE matches DB_ENTRY 1 so uninstallation works :Ooops:
db_pkg_name=`echo "$DB_ENTRY" |cut -f 1 -d '|'`
if [ "$db_pkg_name" != "$DLPKG_NAME" ];then
 DB_ENTRY=`echo "$DB_ENTRY" |sed "s#$db_pkg_name#$DLPKG_NAME#"`
fi
##+++2011-12-27 KRG

#see if a .desktop file was installed, fix category... 120628 improve...
#120818 overhauled. Pkg db now has category[;subcategory] (see 0setup), xdg enhanced (see /etc/xdg and /usr/share/desktop-directories), and generic icons for all subcategories (see /usr/local/lib/X11/mini-icons).
#note, similar code also in Woof 2createpackages.
ONEDOT=""
CATEGORY="`echo -n "$DB_ENTRY" | cut -f 5 -d '|'`" #exs: Document, Document;edit
[ "$CATEGORY" = "" ] && CATEGORY='BuildingBlock' #paranoid precaution.
#xCATEGORY and DEFICON will be the fallbacks if Categories entry in .desktop is invalid...
xCATEGORY="`echo -n "$CATEGORY" | sed -e 's%^%X-%' -e 's%;%-%'`" #ex: X-Document-edit (refer /etc/xdg/menu/*.menu)
DEFICON="`echo -n "$CATEGORY" | sed -e 's%^%mini-%' -e 's%;%-%'`"'.xpm' #ex: mini-Document-edit (refer /usr/local/lib/X11/mini-icons -- these are in jwm search path) 121206 need .xpm extention.
case $CATEGORY in
 Calculate)     CATEGORY='Business'             ; xCATEGORY='X-Business'            ; DEFICON='mini-Business.xpm'            ;; #Calculate is old name, now Business.
 Develop)       CATEGORY='Utility;development'  ; xCATEGORY='X-Utility-development' ; DEFICON='mini-Utility-development.xpm' ;; #maybe an old pkg has this.
 Help)          CATEGORY='Utility;help'         ; xCATEGORY='X-Utility-help'        ; DEFICON='mini-Help.xpm'                ;; #maybe an old pkg has this.
 BuildingBlock) CATEGORY='Utility'              ; xCATEGORY='Utility'               ; DEFICON='mini-BuildingBlock.xpm'       ;; #unlikely to have a .desktop file.
esac
topCATEGORY="`echo -n "$CATEGORY" | cut -f 1 -d ';'`"
tPATTERN="^${topCATEGORY} "
cPATTERN="s%^Categories=.*%Categories=${xCATEGORY}%"
iPATTERN="s%^Icon=.*%Icon=${DEFICON}%"

#121119 if only one .desktop file, first check if a match in /usr/local/petget/categories.dat...
CATDONE='no'
if [ -f /usr/local/petget/categories.dat ];then #precaution, but it will be there.
 NUMDESKFILE="$(grep 'share/applications/.*\.desktop$' $PKGFILEPATH/${DLPKG_NAME}.files | wc -l)"
 if [ "$NUMDESKFILE" = "1" ];then
  #to lookup categories.dat, we need to know the generic name of the package, which may be different from pkg name...
  #db entry format: pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|compileddistro|compiledrelease|repo|
  DBNAMEONLY="$(echo -n "$DB_ENTRY" | cut -f 2 -d '|')"
  DBPATH="$(echo -n "$DB_ENTRY" | cut -f 7 -d '|')"
  DBCOMPILEDDISTRO="$(echo -n "$DB_ENTRY" | cut -f 11 -d '|')"
  [ ! "$DBCOMPILEDDISTRO" ] && DBCOMPILEDDISTRO='puppy' #any name will do here.
  case $DBCOMPILEDDISTRO in
   debian|devuan|ubuntu|raspbian)
    if [ "$DBPATH" ];then #precaution
     xNAMEONLY="$(basename ${DBPATH})"
    else
     xNAMEONLY="$DBNAMEONLY"
    fi
   ;;
   *) xNAMEONLY="$DBNAMEONLY" ;;
  esac
  xnPTN=" ${xNAMEONLY} "
  #130126 categories.dat format changed slightly... 130219 ignore case...
  CATVARIABLE="$(grep -i "$xnPTN" /usr/local/petget/categories.dat | grep '^PKGCAT' | head -n 1 | cut -f 1 -d '=' | cut -f 2,3 -d '_' | tr '_' '-')" #ex: PKGCAT_Graphic_camera=" gphoto2 gtkam "
  if [ "$CATVARIABLE" ];then #ex: Graphic-camera
   xCATEGORY="X-${CATVARIABLE}"
   cPATTERN="s%^Categories=.*%Categories=${xCATEGORY}%" #121120
   CATFOUND="yes"
   CATDONE='yes'
  fi
 fi
fi

for ONEDOT in `grep 'share/applications/.*\.desktop$' $PKGFILEPATH/${DLPKG_NAME}.files | tr '\n' ' '` #121119 exclude other strange .desktop files.
do
 #120901 get rid of param on end of Exec, ex: Exec=gimp-2.8 %U
 #sed -i -e 's/\(^Exec=[^%]*\).*/\1/' -e 's/ *$//' $ONEDOT #'s/\(^Exec=[^ ]*\).*/\1/'
 #121015 01micko: alternative that may work better...
 for PARMATER in u U f F #refer:  http://standards.freedesktop.org/desktop-entry-spec/latest/ar01s06.html
 do
  sed -i "s/ %${PARMATER}//" $ONEDOT
 done
 
 #w478 find if category is already valid (see also 2createpackages)..
 if [ "$CATDONE" = "no" ];then #121119
  CATFOUND="no"
  for ONEORIGCAT in `cat $ONEDOT | grep '^Categories=' | head -n 1 | cut -f 2 -d '=' | tr ';' ' ' | rev` #search in reverse order.
  do
   ONEORIGCAT="`echo -n "$ONEORIGCAT" | rev`" #restore rev of one word.
   oocPATTERN=' '"$ONEORIGCAT"' '
   [ "`echo "$PUPHIERARCHY" | tr -s ' ' | grep "$tPATTERN" | cut -f 3 -d ' ' | tr ',' ' ' | sed -e 's%^% %' -e 's%$% %' | grep "$oocPATTERN"`" != "" ] && CATFOUND="yes"
   #got a problem with sylpheed, "Categories=GTK;Network;Email;News;" this displays in both Network and Internet menus...
   if [ "$CATFOUND" = "yes" ];then
    cPATTERN="s%^Categories=.*%Categories=${ONEORIGCAT}%"
    break
   fi
  done
  #121109 above may fail, as DB_category field may not match that in .desktop file, so leave out that $tPATTERN match in $PUPHIERARCHY...
  if [ "$CATFOUND" = "no" ];then
   for ONEORIGCAT in `cat $ONEDOT | grep '^Categories=' | head -n 1 | cut -f 2 -d '=' | tr ';' ' ' | rev` #search in reverse order.
   do
    ONEORIGCAT="`echo -n "$ONEORIGCAT" | rev`" #restore rev of one word.
    oocPATTERN=' '"$ONEORIGCAT"' '
    [ "`echo "$PUPHIERARCHY" | tr -s ' ' | cut -f 3 -d ' ' | tr ',' ' ' | sed -e 's%^% %' -e 's%$% %' | grep "$oocPATTERN"`" != "" ] && CATFOUND="yes"
    #got a problem with sylpheed, "Categories=GTK;Network;Email;News;" this displays in both Network and Internet menus...
    if [ "$CATFOUND" = "yes" ];then
     cPATTERN="s%^Categories=.*%Categories=${ONEORIGCAT}%"
     break
    fi
   done
  fi
 fi
 sed -i -e "$cPATTERN" $ONEDOT #fix Categories= entry.

 #w019 does the icon exist?...
 ICON="`grep '^Icon=' $ONEDOT | cut -f 2 -d '='`"
 if [ "$ICON" != "" ];then
  [ -e "$ICON" ] && continue #it may have a hardcoded path.
  ICONBASE="`basename "$ICON"`"
  #110706 fix icon entry in .desktop... 110821 improve...
  #first search where jwm looks for icons... 111207...
  FNDICON="`find /usr/local/lib/X11/mini-icons /usr/share/pixmaps -maxdepth 1 -name $ICONBASE -o -name $ICONBASE.png -o -name $ICONBASE.xpm -o -name $ICONBASE.jpg -o -name $ICONBASE.jpeg -o -name $ICONBASE.gif -o -name $ICONBASE.svg | grep -i -E 'png$|xpm$|jpg$|jpeg$|gif$|svg$' | head -n 1`"
  if [ "$FNDICON" ];then
   ICONNAMEONLY="`basename $FNDICON`"
   iPTN="s%^Icon=.*%Icon=${ICONNAMEONLY}%"
   sed -i -e "$iPTN" $ONEDOT
   continue
  else
   #look elsewhere... 111207...
   FNDICON="`find /usr/share/icons /usr/local/share/pixmaps -name $ICONBASE -o -name $ICONBASE.png -o -name $ICONBASE.xpm -o -name $ICONBASE.jpg -o -name $ICONBASE.jpeg -o -name $ICONBASE.gif -o -name $ICONBASE.svg | grep -i -E 'png$|xpm$|jpg$|jpeg$|gif$|svg$' | head -n 1`"
   #111207 look further afield, ex parole pkg has /usr/share/parole/pixmaps/parole.png...
   [ ! "$FNDICON" ] && [ -d /usr/share/$ICONBASE ] && FNDICON="`find /usr/share/${ICONBASE} -name $ICONBASE -o -name $ICONBASE.png -o -name $ICONBASE.xpm -o -name $ICONBASE.jpg -o -name $ICONBASE.jpeg -o -name $ICONBASE.gif -o -name $ICONBASE.svg | grep -i -E 'png$|xpm$|jpg$|jpeg$|gif$|svg$' | head -n 1`"
   #111207 getting desperate...
   [ ! "$FNDICON" ] && FNDICON="`find /usr/share -name $ICONBASE -o -name $ICONBASE.png -o -name $ICONBASE.xpm -o -name $ICONBASE.jpg -o -name $ICONBASE.jpeg -o -name $ICONBASE.gif -o -name $ICONBASE.svg | grep -i -E 'png$|xpm$|jpg$|jpeg$|gif$|svg$' | head -n 1`"
   if [ "$FNDICON" ];then
    ICONNAMEONLY="`basename "$FNDICON"`"
    ln -snf "$FNDICON" /usr/share/pixmaps/${ICONNAMEONLY}
    iPTN="s%^Icon=.*%Icon=${ICONNAMEONLY}%"
    sed -i -e "$iPTN" $ONEDOT
    continue
   fi
  fi
  #substitute a default icon...
  sed -i -e "$iPATTERN" $ONEDOT #note, ONEDOT is name of .desktop file.
 fi
 
 #120926 if a langpack installed, it will have /usr/share/applications.in (see /usr/sbin/momanager, /usr/share/doc/langpack-template/pinstall.sh).
 ABASEDESKTOP="`basename $ONEDOT`"
 ADIRDESKTOP="`dirname $ONEDOT`"
 if [ -f /usr/share/applications.in/${ABASEDESKTOP} ];then
  TARGETLANG="`echo -n $LANG_USER | cut -f 1 -d '_'`" #ex: de
  tlPTN="^Name\[${TARGETLANG}\]"
  if [ "$(grep "$tlPTN" ${ADIRDESKTOP}/${ABASEDESKTOP})" = "" ];then
   if [ "$(grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP})" != "" ];then
    #aaargh, these accursed back-slashes! ....
    INSERTALINE="`grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP} | sed -e 's%\[%\\\\[%' -e 's%\]%\\\\]%'`"
    sed -i -e "s%^Name=%${INSERTALINE}\\nName=%" ${ADIRDESKTOP}/${ABASEDESKTOP}
   fi
  fi
  #do same for Comment field...
  tlPTN="^Comment\[${TARGETLANG}\]"
  if [ "$(grep "$tlPTN" ${ADIRDESKTOP}/${ABASEDESKTOP})" = "" ];then
   if [ "$(grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP})" != "" ];then
    #aaargh, these accursed back-slashes! ....
    INSERTALINE="`grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP} | sed -e 's%\[%\\\\[%' -e 's%\]%\\\\]%'`"
    sed -i -e "s%^Comment=%${INSERTALINE}\\nComment=%" ${ADIRDESKTOP}/${ABASEDESKTOP}
   fi
  fi
  #well, i suppose need this too...
  TARGETLANG="`echo -n $LANG_USER | cut -f 1 -d '.'`" #ex: de_DE
  tlPTN="^Name\[${TARGETLANG}\]"
  if [ "$(grep "$tlPTN" ${ADIRDESKTOP}/${ABASEDESKTOP})" = "" ];then
   if [ "$(grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP})" != "" ];then
    #aaargh, these accursed back-slashes! ....
    INSERTALINE="`grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP} | sed -e 's%\[%\\\\[%' -e 's%\]%\\\\]%'`"
    sed -i -e "s%^Name=%${INSERTALINE}\\nName=%" ${ADIRDESKTOP}/${ABASEDESKTOP}
   fi
  fi
  #do same for Comment field...
  tlPTN="^Comment\[${TARGETLANG}\]"
  if [ "$(grep "$tlPTN" ${ADIRDESKTOP}/${ABASEDESKTOP})" = "" ];then
   if [ "$(grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP})" != "" ];then
    #aaargh, these accursed back-slashes! ....
    INSERTALINE="`grep "$tlPTN" /usr/share/applications.in/${ABASEDESKTOP} | sed -e 's%\[%\\\\[%' -e 's%\]%\\\\]%'`"
    sed -i -e "s%^Comment=%${INSERTALINE}\\nComment=%" ${ADIRDESKTOP}/${ABASEDESKTOP}
   fi
  fi
 fi
 
done

#due to images at / in .pet and post-install script, .files may have some invalid entries...
INSTFILES="`cat $PKGFILEPATH/${DLPKG_NAME}.files`"
echo "$INSTFILES" |
while read ONEFILE
do
 if [ ! -e "$ONEFILE" ];then
  ofPATTERN='^'"$ONEFILE"'$'
  grep -v "$ofPATTERN" $PKGFILEPATH/${DLPKG_NAME}.files > /tmp/ppg_instfiles
  mv -f /tmp/ppg_instfiles $PKGFILEPATH/${DLPKG_NAME}.files
 fi
done

#w482 DB_ENTRY may be missing DB_category and DB_description fields...
#pkgname|nameonly|version|pkgrelease|category|size|path|fullfilename|dependencies|description|
#optionally on the end: compileddistro|compiledrelease|repo| (fields 11,12,13)
DESKTOPFILE="`grep '\.desktop$' $PKGFILEPATH/${DLPKG_NAME}.files | head -n 1`"
if [ "$DESKTOPFILE" != "" ];then
 DB_category="`echo -n "$DB_ENTRY" | cut -f 5 -d '|'`"
 DB_description="`echo -n "$DB_ENTRY" | cut -f 10 -d '|'`"
 CATEGORY="$DB_category"
 DESCRIPTION="$DB_description"
 zCATEGORY="`cat $DESKTOPFILE | grep '^Categories=' | sed -e 's%;$%%' | cut -f 2 -d '=' | rev | cut -f 1 -d ';' | rev`" #121109
 if [ "$zCATEGORY" != "" ];then #121109
  #v424 but want the top-level menu category...
  catPATTERN="[ ,]${zCATEGORY},|[ ,]${zCATEGORY} |[ ,]${zCATEGORY}"'$' #121119 fix bug in pattern.
  CATEGORY="`echo "$PUPHIERARCHY" | cut -f 1 -d '#' | grep -E "$catPATTERN" | grep ':' | cut -f 1 -d ' ' | head -n 1`" #121119 /etc/xdg/menus/hierarchy 
 fi
 if [ "$DB_description" = "" ];then
  DESCRIPTION="`cat $DESKTOPFILE | grep '^Comment=' | cut -f 2 -d '='`"
  [ "$DESCRIPTION" = "" ] && DESCRIPTION="`cat $DESKTOPFILE | grep '^Name=' | cut -f 2 -d '='`"	# shinobar
 fi
 if [ "$DB_category" = "" -o "$DB_description" = "" ];then
  newDB_ENTRY="`echo -n "$DB_ENTRY" | cut -f 1-4 -d '|'`"
  newDB_ENTRY="$newDB_ENTRY"'|'"$CATEGORY"'|'
  newDB_ENTRY="$newDB_ENTRY""`echo -n "$DB_ENTRY" | cut -f 6-9 -d '|'`"
  newDB_ENTRY="$newDB_ENTRY"'|'"$DESCRIPTION"'|'
  newDB_ENTRY="$newDB_ENTRY""`echo -n "$DB_ENTRY" | cut -f 11-14 -d '|'`"
  DB_ENTRY="$newDB_ENTRY"
 fi

echo "$DESKTOPFILE" >> /tmp/ppg-desktop-files

fi

pkgn1=`echo "$DB_ENTRY" | cut -f 2 -d '|'`

update_file_list $pkgn1

echo "$DB_ENTRY" >> /root/.packages/user-installed-packages

#110706 fix 'Exec filename %u' line...
DESKTOPFILES="`grep '\.desktop$' $PKGFILEPATH/${DLPKG_NAME}.files | tr '\n' ' '`"
for ONEDESKTOP in $DESKTOPFILES
do
 sed -i -e 's/ %u$//' $ONEDESKTOP
done

#120907 post-install hacks...
hacks_postinstall $DLPKG_MAIN

#announcement of successful install...
#announcement is done after all downloads, in downloadpkgs.sh...
CATEGORY="`echo -n "$CATEGORY" | cut -f 1 -d ';'`"
[ "$CATEGORY" = "" ] && CATEGORY="none"
[ "$CATEGORY" = "BuildingBlock" ] && CATEGORY="none"
#echo "PACKAGE: $DLPKG_NAME CATEGORY: $CATEGORY"
INSTALL_SUCESS=1


#110503 change ownership of some files if non-root...
#hmmm, i think this will only work if running this script as root...
# (the entry script pkg_chooser.sh has sudo to switch to root)
HOMEUSER="`grep '^tty1' /etc/inittab | tr -s ' ' | cut -f 3 -d ' '`" #root or fido.
if [ "$HOMEUSER" != "root" ];then
 grep -E '^/var|^/root|^/etc' $PKGFILEPATH/${DLPKG_NAME}.files |
 while read FILELINE
 do
  busybox chown ${HOMEUSER}:users "${FILELINE}"
 done
fi

PKGFILE="$PKGFILEPATH/${DLPKG_NAME}.files"

arch1="$(uname -m)"

case $arch1 in
i?86)
 ldpaths="lib lib32 lib/i386-linux-gnu"
;;
x86_64|amd64)
 ldpaths="lib lib64 lib/x86_64-linux-gnu lib/amd64-linux-gnu"
;;
esac

for libfld in $ldpaths
do
	if [ "`grep "^/$libfld/gio/modules/" "$PKGFILE"`" != "" ];then
	 gio-querymodules /$libfld/gio/modules
	fi
done

for pkgpath in /usr /usr/local
do

	#120523 precise puppy needs this... (refer also rc.update and 3builddistro)
	if [ "`grep "$pkgpath/share/glib-2.0/schemas/" "$PKGFILE"`" != "" ];then
	 glib-compile-schemas $pkgpath/share/glib-2.0/schemas
	fi

	if [ "`grep "$pkgpath/share/mime/" "$PKGFILE"`" != "" ];then
	 update-mime-database $pkgpath/share/mime
	fi

	if [ "`grep "$pkgpath/share/icons/hicolor/" "$PKGFILE"`" != "" ];then
	 gtk-update-icon-cache $pkgpath/share/icons/hicolor
	fi

	if [ "`grep "$pkgpath/share/applications/" "$PKGFILE"`" != "" ];then
	 rm -f $pkgpath/share/applications/mimeinfo.cache
	 update-desktop-database $pkgpath/share/applications
	fi
	
	for libfld in $ldpaths
	 do
		if [ "`grep "$pkgpath/$libfld/gio/modules/" "$PKGFILE"`" != "" ];then
		 gio-querymodules $pkgpath/$libfld/gio/modules
		fi
    done	
done

if [ "`grep '/share/fonts/' "$PKGFILE"`" != "" ];then
 fc-cache -f
fi

if [ "`grep '/gconv/' "$PKGFILE" | grep "/lib"`" != "" ];then
 iconvconfig
fi

if [ "`grep '/gdk-pixbuf' "$PKGFILE" | grep "/lib"`" != "" ];then
 gdk-pixbuf-query-loaders --update-cache
fi

if [ "`grep '/pango/' "$PKGFILE" | grep "/lib"`" != "" ];then
 pango-querymodules --update-cache
fi

for gtkver in $GTKVERLIST
do
 if [ "`grep "/gtk-$gtkver" "$PKGFILE" | grep "/immodules" | grep "/lib"`" != "" ];then
  gtk-query-immodules-$gtkver --update-cache
 fi
done

if [ "`grep '/wine' "$PKGFILE"`" != "" ];then
 if [ "$(which xdg-wine)" != "" ] && [ "$(pidof xdg-wine)" == "" ]; then
  xdg-wine
 fi
fi

KVER="$(uname -r)"

if [ "`grep "/lib/modules/$KVER/" "$PKGFILE"`" != "" ];then
 depmod -a
fi

if [ $INSTALL_SUCESS -ne 0 ]; then
echo "Installation sucessful: $DLPKG_BASE (Category: $CATEGORY)"
else
echo "Installation failed: $DLPKG_BASE"
fi
###END###
}

remove_func(){
export OUTPUT_CHARSET=UTF-8
[ "$(locale | grep '^LANG=' | cut -d '=' -f 2)" ] && ORIGLANG="$(locale | grep '^LANG=' | cut -d '=' -f 2)"
. /root/.packages/DISTRO_PKGS_SPECS

pkgnameonly="$1"

rm -f /tmp/ppg-libfiles.txt > /dev/null

#v424 info box, nothing yet installed...


entry=`cat /root/.packages/user-installed-packages | grep "|$pkgnameonly|"`

DB_pkgname=`echo "$entry" | cut -f 1 -d'|'`
pkgmatch=`echo "$entry" | cut -f 2 -d'|'`

if [ "$entry" == "" ]; then
echo "Package not installed: $pkgnameonly"
return
elif [ "$pkgnameonly" != "$pkgmatch" ]; then
echo "Package not installed: $pkgnameonly"
return
fi

#111228 if snapmergepuppy running, wait for it to complete (see also /usr/local/petget/installpkg.sh)...
#note, inverse true, /sbin/pup_event_frontend_d will not run snapmergepuppy if removepreview.sh running.
if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then
  while [ "`pidof snapmergepuppy`" != "" ];do
   sleep 1
  done
fi

echo "Uninstalling $pkgnameonly ..."

if [ -f $PKGFILEPATH/${DB_pkgname}.files ];then
 if [ "$PUP_LAYER" = '/pup_ro2' ]; then #120103 shinobar.
  echo "Restoring pristine state ..."
  
  cat $PKGFILEPATH/${DB_pkgname}.files | grep -E "*\.so" > /tmp/ppg-libfiles.txt
  
  cat $PKGFILEPATH/${DB_pkgname}.files |
  while read ONESPEC
  do
   if [ ! -d "$ONESPEC" ];then
    #120103 shinobar: better way of doing this, look all lower layers...
    Sx=$(ls /initrd/pup_{a,y,ro[0-9]*}"$ONESPEC" 2>/dev/null| grep -v '^/initrd/pup_ro1/')
    INAY=$(echo $Sx | grep -E 'pup_a|pup_y')
    if [ "$INAY" != "" ]; then
     S=$(ls /initrd/pup_{a,y}"$ONESPEC" 2>/dev/null| grep -v '^/initrd/pup_ro1/'| tail -n 1)
    else
     S=$(ls /initrd/pup_ro{?,??}"$ONESPEC" 2>/dev/null| grep -v '^/initrd/pup_ro1/'| head -n 1)
    fi # pup_ro2 - pup_ro99
    if [ "$S" ]; then
     #the problem is, deleting the file on the top layer places a ".wh" whiteout file,
     #that hides the original file. what we want is to remove the installed file, and
     #restore the original pristine file...
     
     #This resolve symlink problems
     flname=`basename $ONESPEC`
     puprw=`find /initrd -type f -name "$flname" | grep "pup_rw"`
     
     if [ "$puprw" != "" ]; then
     
     rm -f "$ONESPEC"
		
		puprox=`find /initrd -type f -name "$flname" | grep "pup_ro" | grep "$ONESPEC"`

		if [ "$puprox" != "" ]; then
		  cp -a --remove-destination "$S" "$ONESPEC"
		fi
		
     else
     cp -a --remove-destination "$S" "$ONESPEC" #120103 shinobar.
     fi
     
     #120103 apparently for odd# PUPMODEs, save layer may have a lurking old file and/or whiteout...
     if [ $PUPMODE -eq 3 -o $PUPMODE -eq 7 -o $PUPMODE -eq 13 ];then
      [ -f "/initrd${SAVE_LAYER}${ONESPEC}" ] && rm -f "/initrd${SAVE_LAYER}${ONESPEC}" #normally /pup_ro1
      BN="`basename "$ONESPEC"`"
      DN="`dirname "$ONESPEC"`"
      [ -f "/initrd${SAVE_LAYER}${DN}/.wh.${BN}" ] && rm -f "/initrd${SAVE_LAYER}${DN}/.wh.${BN}"
     fi
    else
     rm -f "$ONESPEC"
    fi
   fi
  done
 fi
 #do it again, looking for empty directories...
 cat $PKGFILEPATH/${DB_pkgname}.files |
 while read ONESPEC
 do
  if [ -d "$ONESPEC" ];then
   [ "`ls -1 "$ONESPEC"`" = "" ] && rmdir "$ONESPEC" 2>/dev/null #120107
  fi
 done
 ###+++2011-12-27 KRG
else
 firstchar=`echo ${DB_pkgname} | cut -c 1`
 possiblePKGS=`find /root/.packages/package-files -type f -iname "$firstchar*.files"`
 possible5=`echo "$possiblePKGS" | head -n5`
 count=`echo "$possiblePKGS" | wc -l`
 [ ! "$count" ] && count=0
 [ ! "$possiblePKGS" ] && possiblePKGS="$(gettext 'No pkgs beginning with') ${firstchar} $(gettext 'found')"
 if [ "$count" -le '5' ];then
  WARNMSG="$possiblePKGS"
 else
  WARNMSG="$(gettext 'Found more than 5 pkgs starting with') ${firstchar}.
$(gettext 'The first 5 are')
$possible5"
 fi
 
  echo "$(gettext 'No file named ' ) ${DB_pkgname}.files $(gettext ' found. Refusing cowardly to remove the package. Possible solution: Edit /root/.packages/user-installed-packages and start again.')"
  return 101
   
fi


if [ "$PUPMODE" = "2" ]; then
#any user-installed deps?...
remPATTERN='^'"$DB_pkgname"'|'
DEP_PKGS="`grep "$remPATTERN" /root/.packages/user-installed-packages | cut -f 9 -d '|' | tr ',' '\n' | grep -v '^\\-' | sed -e 's%^+%%' |cut -f1 -d '&'`" #names-only, one each line. 

#131222 do not uninstall if other-installed depend on it...
echo -n '' > /tmp/ppg-other-installed-deps
for ADEP in $DEP_PKGS
do
 if [ "$(grep ${ADEP} /tmp/pkgs_to_remove)" = "" ]; then
  PTN2="|${ADEP}|"
  DEPPKG="$(grep "$PTN2" /root/.packages/user-installed-packages | cut -f 1 -d '|')"
  [ "$DEPPKG" ] && echo "$DEPPKG" >> /tmp/ppg-other-installed-deps
 else
  echo "go on"
 fi
done
if [ -s /tmp/ppg-other-installed-deps ];then
 OTHERDEPS="$(sort -u /tmp/ppg-other-installed-deps | tr '\n' ' ')"
 echo "$(gettext 'Cannot uninstall'): ${DB_pkgname}
 $(gettext 'Sorry, but these other installed packages depend on the package that you want to uninstall'): ${OTHERDEPS}
 $(gettext 'Aborting uninstall operation.')"
 return 1
fi

echo "Performing audit for ${DB_pkgname}... "

#131221 131222
#check install history, so know if can safely uninstall...
REMLIST="${DB_pkgname}"
echo -n "" > /tmp/ppg-FILECLASHES
echo -n "" > /tmp/ppg-CLASHPKGS
grep -v '/$' $PKGFILEPATH/${DB_pkgname}.files > /tmp/ppg-${DB_pkgname}.filesFILESONLY #/ on end, it is a directory entry.
LATERINSTALLED="$(cat /root/.packages/user-installed-packages | cut -f 1 -d '|' | tr '\n' ' ' | grep -o " ${DB_pkgname} .*" | cut -f 3- -d ' ')"

for ALATERPKG in $LATERINSTALLED
do
 if [ -f /audit/${ALATERPKG}-DEPOSED.sfs ];then
  mkdir /audit/${ALATERPKG}-DEPOSED
  busybox mount -t squashfs -o loop,ro /audit/${ALATERPKG}-DEPOSED.sfs /audit/${ALATERPKG}-DEPOSED
  FNDFILES="$(cat /tmp/ppg-${DB_pkgname}.filesFILESONLY | xargs -I FULLPATHSPEC ls -1 /audit/${ALATERPKG}-DEPOSEDFULLPATHSPEC 2>/dev/null | sed -e "s%^/audit/${ALATERPKG}%%")"
  if [ "$FNDFILES" ];then
   #echo "" >> /tmp/ppg-FILECLASHES
   #echo "PACKAGE: ${ALATERPKG}" >> /tmp/ppg-FILECLASHES
   echo "$FNDFILES" >> /tmp/ppg-FILECLASHES
   echo "${ALATERPKG}" >> /tmp/ppg-CLASHPKGS
  fi
  busybox umount /audit/${ALATERPKG}-DEPOSED
  rmdir /audit/${ALATERPKG}-DEPOSED
 fi
done

if [ -s /tmp/ppg-CLASHPKGS ];then
 #a later-installed package is going to be compromised if uninstall ${DB_pkgname}.
 #131222 much simpler...
 FILECLASHES="$(sort -u /tmp/ppg-FILECLASHES | grep -v '^$')"
 rm -rf /tmp/ppg-savedfiles 2>/dev/null
 mkdir /tmp/ppg-savedfiles
 echo "$FILECLASHES" |
 while read AFILE
 do
  APATH="$(dirname "$AFILE")"
  mkdir -p /tmp/ppg-savedfiles"${APATH}"
  cp -a -f "${AFILE}" /tmp/ppg-savedfiles"${APATH}"/
 done
fi
#end 131221 131222

#131230 from here down, use busybox applets only...
export LANG=C
#delete files...
busybox cat $PKGFILEPATH/${DB_pkgname}.files | busybox grep -v '/$' | busybox xargs busybox rm -f #/ on end, it is a directory entry.
#do it again, looking for empty directories...
busybox cat $PKGFILEPATH/${DB_pkgname}.files |
while read ONESPEC
do
 if [ -d "$ONESPEC" ];then
  [ "`busybox ls -1 "$ONESPEC"`" = "" ] && busybox rmdir "$ONESPEC" 2>/dev/null #120107
 fi
done

echo "Restoring -DEPOSED files..."

#131222 restore files that were -DEPOSED when this pkg installed...
if [ -f /audit/${DB_pkgname}-DEPOSED.sfs ];then
 busybox mkdir -p /audit/${DB_pkgname}-DEPOSED
 busybox mount -t squashfs -o loop,ro /audit/${DB_pkgname}-DEPOSED.sfs /audit/${DB_pkgname}-DEPOSED
 DIRECTSAVEPATH="/audit/${DB_pkgname}-DEPOSED"
 #same code as in installpkg.sh... 131230 cp is compiled statically, need full version...
 cp -a -f --remove-destination ${DIRECTSAVEPATH}/* /  2> /tmp/ppg-install-cp-errlog
 busybox sync
 #can have a problem if want to replace a folder with a symlink. for example, got this error:
 # cp: cannot overwrite directory '/usr/share/mplayer/skins' with non-directory
 #3builddistro has this fix... which is a vice-versa situation...
 #firstly, the vice-versa, source is a directory, target is a symlink...
 CNT=0
 while [ -s /tmp/ppg-install-cp-errlog ];do
  echo -n "" > /tmp/ppg-install-cp-errlog2
  echo -n "" > /tmp/ppg-install-cp-errlog3
  busybox cat /tmp/ppg-install-cp-errlog | busybox grep 'cannot overwrite non-directory' | busybox tr '[`‘’]' "'" | busybox cut -f 2 -d "'" |
  while read ONEDIRSYMLINK #ex: /usr/share/mplayer/skins
  do
   #adding that extra trailing / does the trick... 131230 full cp...
   cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}"/* "${ONEDIRSYMLINK}"/ 2> /tmp/ppg-install-cp-errlog2
  done
  #secondly, which is our mplayer example, source is a symlink, target is a folder...
  busybox cat /tmp/ppg-install-cp-errlog | busybox grep 'cannot overwrite directory' | busybox grep 'with non-directory' | busybox tr '[`‘’]' "'" | busybox cut -f 2 -d "'" |
  while read ONEDIRSYMLINK #ex: /usr/share/mplayer/skins
  do
   busybox mv -f "${ONEDIRSYMLINK}" "${ONEDIRSYMLINK}"TEMP
   busybox rm -rf "${ONEDIRSYMLINK}"TEMP
   DIRPATH="$(busybox dirname "${ONEDIRSYMLINK}")"
   cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}" "${DIRPATH}"/ 2> /tmp/ppg-install-cp-errlog3
  done
  busybox cat /tmp/ppg-install-cp-errlog2 >> /tmp/ppg-install-cp-errlog3
  busybox cat /tmp/ppg-install-cp-errlog3 > /tmp/ppg-install-cp-errlog
  busybox sync
  CNT=`busybox expr $CNT + 1`
  [ $CNT -gt 10 ] && break #something wrong, get out.
 done
 busybox umount /audit/${DB_pkgname}-DEPOSED
 busybox rm -rf /audit/${DB_pkgname}-DEPOSED
 busybox rm -f /audit/${DB_pkgname}-DEPOSED.sfs
fi

#131222 restore latest files, needed by later-installed packages...
#note, manner in which old files got saved may result in wrong dirs instead of symlinks, hence need fixes below...
if [ -s /tmp/ppg-CLASHPKGS ];then
 DIRECTSAVEPATH="/tmp/ppg-savedfiles"
 #same code as in installpkg.sh...
 cp -a -f --remove-destination ${DIRECTSAVEPATH}/* /  2> /tmp/ppg-install-cp-errlog
 busybox sync
 #can have a problem if want to replace a folder with a symlink. for example, got this error:
 # cp: cannot overwrite directory '/usr/share/mplayer/skins' with non-directory
 #3builddistro has this fix... which is a vice-versa situation...
 #firstly, the vice-versa, source is a directory, target is a symlink...
 CNT=0
 while [ -s /tmp/ppg-install-cp-errlog ];do
  echo -n "" > /tmp/ppg-install-cp-errlog2
  echo -n "" > /tmp/ppg-install-cp-errlog3
  busybox cat /tmp/ppg-install-cp-errlog | busybox grep 'cannot overwrite non-directory' | busybox tr '[`‘’]' "'" | busybox cut -f 2 -d "'" |
  while read ONEDIRSYMLINK #ex: /usr/share/mplayer/skins
  do
   #adding that extra trailing / does the trick...
   cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}"/* "${ONEDIRSYMLINK}"/ 2> /tmp/ppg-install-cp-errlog2
  done
  #secondly, which is our mplayer example, source is a symlink, target is a folder...
  busybox cat /tmp/ppg-install-cp-errlog | busybox grep 'cannot overwrite directory' | busybox grep 'with non-directory' | busybox tr '[`‘’]' "'" | busybox cut -f 2 -d "'" |
  while read ONEDIRSYMLINK #ex: /usr/share/mplayer/skins
  do
   busybox mv -f "${ONEDIRSYMLINK}" "${ONEDIRSYMLINK}"TEMP
   busybox rm -rf "${ONEDIRSYMLINK}"TEMP
   DIRPATH="$(dirname "${ONEDIRSYMLINK}")"
   cp -a -f --remove-destination ${DIRECTSAVEPATH}"${ONEDIRSYMLINK}" "${DIRPATH}"/ 2> /tmp/ppg-install-cp-errlog3
  done
  busybox cat /tmp/ppg-install-cp-errlog2 >> /tmp/ppg-install-cp-errlog3
  busybox cat /tmp/ppg-install-cp-errlog3 > /tmp/ppg-install-cp-errlog
  busybox sync
  CNT=`busybox expr $CNT + 1`
  [ $CNT -gt 10 ] && break #something wrong, get out.
 done
 busybox rm -rf /tmp/ppg-savedfiles
 busybox rm -f /tmp/ppg-CLASHPKGS
 busybox rm -f /tmp/ppg-FILECLASHES
fi
#end 131220 131222
export LANG="$ORIGLANG"
#131230 ...end need to use busybox applets?

fi

UPDATE_MENUS=''
UPDATE_MENUS=yes



if [ "$UPDATE_MENUS" = "yes" ]; then
 #fix menu...
 #master help index has to be updated...
 ##to speed things up, find the help files in the new pkg only...
# /usr/sbin/indexgen.sh #${WKGDIR}/${APKGNAME}

 #110706 update menu if .desktop file exists...
 if [ -f $PKGFILEPATH/${DB_pkgname}.files ];then
  if [ "`grep '\.desktop$' $PKGFILEPATH/${DB_pkgname}.files`" != "" ];then
   #Reconstruct configuration files for JWM, Fvwm95, IceWM...
   echo "" > /tmp/ppg-fixmenus
  fi
 fi
fi

if [ -f $PKGFILEPATH/${DB_pkgname}.files ]; then
 pkgfile2="$PKGFILEPATH/${DB_pkgname}.files"
else
 pkgfile2="/root/.packages/${DB_pkgname}.files"
fi

PKGFILE="$pkgfile2"

arch1="$(uname -m)"

case $arch1 in
i?86)
 ldpaths="lib lib32 lib/i386-linux-gnu"
;;
x86_64|amd64)
 ldpaths="lib lib64 lib/x86_64-linux-gnu lib/amd64-linux-gnu"
;;
esac

for libfld in $ldpaths
do
	if [ "`grep "^/$libfld/gio/modules/" "$PKGFILE"`" != "" ];then
	 gio-querymodules /$libfld/gio/modules
	fi
done

for pkgpath in /usr /usr/local
do

	#120523 precise puppy needs this... (refer also rc.update and 3builddistro)
	if [ "`grep "$pkgpath/share/glib-2.0/schemas/" "$PKGFILE"`" != "" ];then
	 glib-compile-schemas $pkgpath/share/glib-2.0/schemas
	fi

	if [ "`grep "$pkgpath/share/mime/" "$PKGFILE"`" != "" ];then
	 update-mime-database $pkgpath/share/mime
	fi

	if [ "`grep "$pkgpath/share/icons/hicolor/" "$PKGFILE"`" != "" ];then
	 gtk-update-icon-cache $pkgpath/share/icons/hicolor
	fi

	if [ "`grep "$pkgpath/share/applications/" "$PKGFILE"`" != "" ];then
	 rm -f $pkgpath/share/applications/mimeinfo.cache
	 update-desktop-database $pkgpath/share/applications
	fi
	
	for libfld in $ldpaths
	 do
		if [ "`grep "$pkgpath/$libfld/gio/modules/" "$PKGFILE"`" != "" ];then
		 gio-querymodules $pkgpath/$libfld/gio/modules
		fi
    done	
done

if [ "`grep '/share/fonts/' "$PKGFILE"`" != "" ];then
 fc-cache -f
fi

if [ "`grep '/gconv/' "$PKGFILE" | grep "/lib"`" != "" ];then
 iconvconfig
fi

if [ "`grep '/gdk-pixbuf' "$PKGFILE" | grep "/lib"`" != "" ];then
 gdk-pixbuf-query-loaders --update-cache
fi

if [ "`grep '/pango/' "$PKGFILE" | grep "/lib"`" != "" ];then
 pango-querymodules --update-cache
fi

for gtkver in $GTKVERLIST
do
 if [ "`grep "/gtk-$gtkver" "$PKGFILE" | grep "/immodules" | grep "/lib"`" != "" ];then
  gtk-query-immodules-$gtkver --update-cache
 fi
done

if [ "`grep '/wine' "$PKGFILE"`" != "" ];then
 if [ "$(which xdg-wine)" != "" ] && [ "$(pidof xdg-wine)" == "" ]; then
  xdg-wine
 fi
fi

KVER="$(uname -r)"

if [ "`grep "/lib/modules/$KVER/" "$PKGFILE"`" != "" ];then
 depmod -a
fi

#what about any user-installed deps...
remPATTERN='^'"$DB_pkgname"'|'
#110211 shinobar: was the dependency logic inverted...
DEP_PKGS="`grep "$remPATTERN" /root/.packages/user-installed-packages | cut -f 9 -d '|' | tr ',' '\n' | grep -v '^\\-' | sed -e 's%^+%%' | cut -f1 -d '&'`"
#remove records of pkg...
rm -f $PKGFILEPATH/${DB_pkgname}.files
rm -f /root/.packages/${DB_pkgname}.files

grep -v "$remPATTERN" /root/.packages/user-installed-packages > /tmp/ppg-user-installed-pkgs-rem
cp -f /tmp/ppg-user-installed-pkgs-rem /root/.packages/user-installed-packages

#v424 .pet pckage may have post-uninstall script, which was originally named puninstall.sh
#but /usr/local/petget/installpkg.sh moved it to $PKGRMSCRIPT/$DB_pkgname.remove
if [ -f $PKGRMSCRIPT/${DB_pkgname}.remove ];then
 nohup /bin/sh $PKGRMSCRIPT/${DB_pkgname}.remove &
 sleep 0.2
fi

if [ -f /root/.packages/pup-keyword/${DB_pkgname}.keyword ]; then
 rm -f /root/.packages/pup-keyword/${DB_pkgname}.keyword
fi

if [ -e /tmp/ppg-libfiles.txt ] && [ $PUPMODE -ne 2 ]; then
 fix_broken_symlinks
fi

rm -f /tmp/ppg-libfiles.txt > /dev/null

#remove temp file so main gui window will re-filter pkgs display...
FIRSTCHAR="`echo -n "$DB_pkgname" | cut -c 1 | tr '[A-Z]' '[a-z]'`"
rm -f /tmp/ppg-fltrd_repo_${FIRSTCHAR}* 2>/dev/null
rm -f /tmp/ppg-fltrd_repo_?${FIRSTCHAR}* 2>/dev/null
[ "`echo -n "$FIRSTCHAR" | grep '[0-9]'`" != "" ] && rm -f /tmp/ppg-fltrd_repo_0* 2>/dev/null

#announce any deps that might be removable...
echo -n "" > /tmp/ppg-deps-maybe-rem
echo -n "" > /tmp/ppg-deps-maybe-remove
cut -f 1,2,10 -d '|' /root/.packages/user-installed-packages |
while read ONEDB
do
 ONE_pkgname="`echo -n "$ONEDB" | cut -f 1 -d '|'`"
 ONE_nameonly="`echo -n "$ONEDB" | cut -f 2 -d '|'`"
 ONE_description="`echo -n "$ONEDB" | cut -f 3 -d '|'`"
 opPATTERN='^'"$ONE_nameonly"'$'
 [ "`echo "$DEP_PKGS" | grep "$opPATTERN"`" != "" ] && echo "$ONE_pkgname DESCRIPTION: $ONE_description" >> /tmp/ppg-deps-maybe-rem && echo "$ONE_pkgname" >> /tmp/ppg-deps-maybe-remove
done
EXTRAMSG=""
if [ -s /tmp/ppg-deps-maybe-rem ];then
 #nah, just list the names, not descriptions...
 MAYBEREM="`cat /tmp/ppg-deps-maybe-rem | cut -f 1 -d ' ' | tr '\n' ' '` "
 EXTRAMSG="$(gettext 'Perhaps you do not need these dependencies that you had also installed:') ${MAYBEREM} perhaps make a note of the package names on a scrap of paper right now"
fi



#announce success...

echo  "$DB_pkgname $(gettext 'has been removed.')"

if [ "${EXTRAMSG}" != "" ]; then
echo "${EXTRAMSG}"
fi

###+++2011-12-27 KRG
#emitting exit_unlockcode for some windowmanager depending on dbus
#popup a message window saying the program stopped unexpectedly
#ie (old) enlightenment
rm -f $HOME/nohup.out
return 0
###+++2011-12-27 KRG
###END###	
	
}

process_remove(){
CNT1=0
pkgnames=""

for pkg in $prepkgs
do

	if [ $CNT1 -gt 0 ] && [ "$pkg" != "" ]; then
		if [ "$pkgnames" != "" ]; then
		pkgnames="$pkgnames $pkg"
		else
		pkgnames="$pkg"
		fi
	fi

CNT1=`expr $CNT1 + 1`

done

if [ "$pkgnames" == "" ]; then
echo "No package specified"
exit_unlock
fi

for pkg1 in $pkgnames
do
remove_func "$pkg1"
done

}

menufix(){

echo "Fixing menu entries..."	
	
update_menu_func
   
}

view_installed(){

if [ "`cat /root/.packages/user-installed-packages`" = "" ];then #fix for ziggi
 echo "$(gettext 'There are no user-installed packages yet, so nothing to uninstall!')"
 return
fi

while IFS='' read -r line || [[ -n $line ]]
do
	if [ "$line" != "" ]; then
	echo $line | cut -f 2 -d '|'
	fi
done < /root/.packages/user-installed-packages

}

search_pkg_func(){
key1="$1"
pattern="\$2 ~ /$key1*/"
awk -F "|" "$pattern" ~/.packages/pkg-master-db | cut -f 2 -d '|'	
}

process_search(){
	
CNT1=0
pkgnames=""

for pkg in $prepkgs
do

	if [ $CNT1 -gt 0 ] && [ "$pkg" != "" ]; then
		if [ "$pkgnames" != "" ]; then
		pkgnames="$pkgnames $pkg"
		else
		pkgnames="$pkg"
		fi
	fi

CNT1=`expr $CNT1 + 1`

done

if [ "$pkgnames" == "" ]; then
echo "No package specified"
exit_unlock
fi

if [ ! -f $PKGMDB ]; then
echo "Generate master database first by typing"
echo "$0 update"
echo "Otherwise load a database file by typing"
echo "$0 update loaddb [package db file]"
exit_unlock
fi


for pkg1 in $pkgnames
do
search_pkg_func $pkg1
done

}

PNAME=`basename $0`

if [ "$1" != "update" ] && [ "$1" != "install" ] && [ "$1" != "list" ] && [ "$1" != "download" ] && [ "$1" != "info" ] && [ "$1" != "stat" ] && [ "$1" != "rollback" ] && [ "$1" != "package" ]  && [ "$1" != "remove" ] &&  [ "$1" != "view-installed" ] &&  [ "$1" != "loaddb" ] &&  [ "$1" != "search" ]; then
	if [ "$1" == "" ]; then
	echo "Puppy package automation system (works like apt-get)."
	echo ""
	echo "Usage $0 [options] [package-name]"
	echo ""
	echo "Options:"
	echo "update - build/update master package database"
	echo "install - install the package and its dependencies"
	echo "download - download only the package and its dependencies"
	echo "info - view package information"
	echo "list - list all the packages in the master package database"
	echo "stat - show number of packages in the master package database"
	echo "rollback - rollback master package database to previous one"
	echo "package - install using a package file"
	echo "remove - remove a installed package"
	echo "view-installed - show installed user packages"
	echo "loaddb - load a package database file"
	echo "search - search a package name in the database file"
	echo ""
	echo "NOTE: Run PPM and update its package database first. Before updating the master package database or load a package database file as master database."
	else
	echo "$(basename $0): invalid command"
	fi
exit_unlock
elif [ "$1" == "update" ]; then
check_process_lock
touch /tmp/process-ppg.lock
update_db
exit_unlock
elif [ "$1" == "list" ]; then
listdb
elif [ "$1" == "view-installed" ]; then
view_installed
elif [ "$1" == "install" ]; then
check_process_lock
touch /tmp/process-ppg.lock
mcommand="install"
prepkgs="$@"
process_packages
clean_temp_file
exit_unlock
elif [ "$1" == "download" ]; then
check_process_lock
touch /tmp/process-ppg.lock
mcommand="download"
prepkgs="$@"
process_packages
clean_temp_file
exit_unlock
elif [ "$1" == "info" ]; then
mcommand="info"
prepkgs="$@"
process_info
elif [ "$1" == "search" ]; then
mcommand="searrch"
prepkgs="$@"
process_search
elif [ "$1" == "rollback" ]; then

check_process_lock
touch /tmp/process-ppg.lock

	if [ ! -f $PKGMDB.old ]; then
	echo "There is nothing to rollback"
	exit_unlock
	fi

mv -f $PKGMDB.old $PKGMDB

echo "The master package database is now rolled back"

clean_temp_file
exit_unlock

elif [ "$1" == "stat" ]; then
	if [ ! -f $PKGMDB ]; then
	echo "Generate master database first by typing"
	echo "$0 update"
	echo "Otherwise load a database file by typing"
	echo "$0 update loaddb [package db file]"
	exit_unlock
	fi
echo "$(cat $PKGMDB | wc -l) packages in the master database."
elif [ "$1" == "package" ]; then

check_process_lock
touch /tmp/process-ppg.lock


	if [ ! -f "$2" ]; then
	echo "Package is not found: $2"
	exit_unlock
	fi	
	pkgfile3="$2"
	install_func "$pkgfile3"
	
	sleep 1
	
	if [ -s /tmp/ppg-desktop-files ]; then
	menufix
	fi
	
clean_temp_file
exit_unlock	
		
elif [ "$1" == "remove" ]; then

check_process_lock
touch /tmp/process-ppg.lock

	prepkgs="$@"
    process_remove
    
    sleep 1
    
	if [ -s /tmp/ppg-fixmenus ]; then
	menufix
	fi

clean_temp_file
exit_unlock	
	
elif [ "$1" == "loaddb" ]; then

check_process_lock
touch /tmp/process-ppg.lock
	
	pkgdb3="$2"
	
	if [ ! -f "$pkgdb3" ]; then
	echo "Package database file is not found: $pkgdb3"
	exit_unlock
	fi
	
	if [ -f $PKGMDB ]; then
	mv -f $PKGMDB $PKGMDB.old
	fi

	cp -f $pkgdb3 $PKGMDB
	
	echo "Package database file is now loaded"

clean_temp_file
exit_unlock	
	
fi

